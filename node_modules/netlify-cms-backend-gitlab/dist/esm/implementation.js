"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _trimStart = _interopRequireDefault(require("lodash/trimStart"));

var _semaphore = _interopRequireDefault(require("semaphore"));

var _commonTags = require("common-tags");

var _netlifyCmsLibUtil = require("netlify-cms-lib-util");

var _AuthenticationPage = _interopRequireDefault(require("./AuthenticationPage"));

var _API = _interopRequireDefault(require("./API"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _templateObject() {
  const data = _taggedTemplateLiteral(["\n        Repo \"", "\" not found.\n\n        Please ensure the repo information is spelled correctly.\n\n        If the repo is private, make sure you're logged into a GitLab account with access.\n      "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const MAX_CONCURRENT_DOWNLOADS = 10;

class GitLab {
  constructor(config) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _defineProperty(this, "fetchFiles", files => {
      const sem = (0, _semaphore.default)(MAX_CONCURRENT_DOWNLOADS);
      const promises = [];
      files.forEach(file => {
        promises.push(new Promise(resolve => sem.take(() => this.api.readFile(file.path, file.id).then(data => {
          resolve({
            file,
            data
          });
          sem.leave();
        }).catch(function () {
          let error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
          sem.leave();
          console.error("failed to load file from GitLab: ".concat(file.path));
          resolve({
            error
          });
        }))));
      });
      return Promise.all(promises).then(loadedEntries => loadedEntries.filter(loadedEntry => !loadedEntry.error));
    });

    this.config = config;
    this.options = _objectSpread({
      proxied: false,
      API: null
    }, options);

    if (this.options.useWorkflow) {
      throw new Error('The GitLab backend does not support the Editorial Workflow.');
    }

    if (!this.options.proxied && config.getIn(['backend', 'repo']) == null) {
      throw new Error('The GitLab backend needs a "repo" in the backend configuration.');
    }

    this.api = this.options.API || null;
    this.repo = config.getIn(['backend', 'repo'], '');
    this.branch = config.getIn(['backend', 'branch'], 'master');
    this.api_root = config.getIn(['backend', 'api_root'], 'https://gitlab.com/api/v4');
    this.token = '';
  }

  authComponent() {
    return _AuthenticationPage.default;
  }

  restoreUser(user) {
    return this.authenticate(user);
  }

  async authenticate(state) {
    this.token = state.token;
    this.api = new _API.default({
      token: this.token,
      branch: this.branch,
      repo: this.repo,
      api_root: this.api_root
    });
    const user = await this.api.user();
    const isCollab = await this.api.hasWriteAccess(user).catch(error => {
      error.message = (0, _commonTags.stripIndent)(_templateObject(), this.repo);
      throw error;
    }); // Unauthorized user

    if (!isCollab) {
      throw new Error('Your GitLab user account does not have access to this repo.');
    } // Authorized user


    return _objectSpread({}, user, {
      login: user.username,
      token: state.token
    });
  }

  logout() {
    this.token = null;
    return;
  }

  getToken() {
    return Promise.resolve(this.token);
  }

  entriesByFolder(collection, extension) {
    return this.api.listFiles(collection.get('folder')).then((_ref) => {
      let {
        files,
        cursor
      } = _ref;
      return this.fetchFiles(files.filter(file => file.name.endsWith('.' + extension))).then(fetchedFiles => {
        const returnedFiles = fetchedFiles;
        returnedFiles[_netlifyCmsLibUtil.CURSOR_COMPATIBILITY_SYMBOL] = cursor;
        return returnedFiles;
      });
    });
  }

  allEntriesByFolder(collection, extension) {
    return this.api.listAllFiles(collection.get('folder')).then(files => this.fetchFiles(files.filter(file => file.name.endsWith('.' + extension))));
  }

  entriesByFiles(collection) {
    const files = collection.get('files').map(collectionFile => ({
      path: collectionFile.get('file'),
      label: collectionFile.get('label')
    }));
    return this.fetchFiles(files).then(fetchedFiles => {
      const returnedFiles = fetchedFiles;
      return returnedFiles;
    });
  }

  // Fetches a single entry.
  getEntry(collection, slug, path) {
    return this.api.readFile(path).then(data => ({
      file: {
        path
      },
      data
    }));
  }

  getMedia() {
    return this.api.listAllFiles(this.config.get('media_folder')).then(files => files.map((_ref2) => {
      let {
        id,
        name,
        path
      } = _ref2;
      return {
        id,
        name,
        path,
        displayURL: {
          id,
          name,
          path
        }
      };
    }));
  }

  getMediaDisplayURL(displayURL) {
    this._mediaDisplayURLSem = this._mediaDisplayURLSem || (0, _semaphore.default)(MAX_CONCURRENT_DOWNLOADS);
    const {
      id,
      name,
      path
    } = displayURL;
    return new Promise((resolve, reject) => this._mediaDisplayURLSem.take(() => this.api.readFile(path, id, {
      parseText: false
    }).then(blob => {
      // svgs are returned with mimetype "text/plain" by gitlab
      if (blob.type === 'text/plain' && name.match(/\.svg$/i)) {
        return new window.Blob([blob], {
          type: 'image/svg+xml'
        });
      }

      return blob;
    }).then(blob => URL.createObjectURL(blob)).then(resolve, reject).finally(() => this._mediaDisplayURLSem.leave())));
  }

  async persistEntry(entry, mediaFiles) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return this.api.persistFiles([entry], options);
  }

  async persistMedia(mediaFile) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    await this.api.persistFiles([mediaFile], options);
    const {
      value,
      path,
      fileObj
    } = mediaFile;
    return {
      name: value,
      size: fileObj.size,
      path: (0, _trimStart.default)(path, '/')
    };
  }

  deleteFile(path, commitMessage, options) {
    return this.api.deleteFile(path, commitMessage, options);
  }

  traverseCursor(cursor, action) {
    return this.api.traverseCursor(cursor, action).then(async (_ref3) => {
      let {
        entries,
        cursor: newCursor
      } = _ref3;
      return {
        entries: await Promise.all(entries.map(file => this.api.readFile(file.path, file.id).then(data => ({
          file,
          data
        })))),
        cursor: newCursor
      };
    });
  }

}

exports.default = GitLab;