"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _result2 = _interopRequireDefault(require("lodash/result"));

var _partial2 = _interopRequireDefault(require("lodash/partial"));

var _flow2 = _interopRequireDefault(require("lodash/flow"));

var _netlifyCmsLibUtil = require("netlify-cms-lib-util");

var _jsBase = require("js-base64");

var _immutable = require("immutable");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class API {
  constructor(config) {
    var _this = this;

    _defineProperty(this, "withAuthorizationHeaders", req => _netlifyCmsLibUtil.unsentRequest.withHeaders(this.token ? {
      Authorization: "Bearer ".concat(this.token)
    } : {}, req));

    _defineProperty(this, "buildRequest", req => (0, _flow2.default)([_netlifyCmsLibUtil.unsentRequest.withRoot(this.api_root), this.withAuthorizationHeaders, _netlifyCmsLibUtil.unsentRequest.withTimestamp])(req));

    _defineProperty(this, "request", async req => (0, _flow2.default)([this.buildRequest, _netlifyCmsLibUtil.unsentRequest.performRequest, p => p.catch(err => Promise.reject(new _netlifyCmsLibUtil.APIError(err.message, null, 'GitLab')))])(req));

    _defineProperty(this, "catchFormatErrors", (format, formatter) => res => {
      try {
        return formatter(res);
      } catch (err) {
        throw new Error("Response cannot be parsed into the expected format (".concat(format, "): ").concat(err.message));
      }
    });

    _defineProperty(this, "responseFormats", (0, _immutable.fromJS)({
      json: async res => {
        const contentType = res.headers.get('Content-Type');

        if (contentType !== 'application/json' && contentType !== 'text/json') {
          throw new Error("".concat(contentType, " is not a valid JSON Content-Type"));
        }

        return res.json();
      },
      text: async res => res.text(),
      blob: async res => res.blob()
    }).mapEntries((_ref) => {
      let [format, formatter] = _ref;
      return [format, this.catchFormatErrors(format, formatter)];
    }));

    _defineProperty(this, "parseResponse", async (res, _ref2) => {
      let {
        expectingOk = true,
        expectingFormat = 'text'
      } = _ref2;
      let body;

      try {
        const formatter = this.responseFormats.get(expectingFormat, false);

        if (!formatter) {
          throw new Error("".concat(expectingFormat, " is not a supported response format."));
        }

        body = await formatter(res);
      } catch (err) {
        throw new _netlifyCmsLibUtil.APIError(err.message, res.status, 'GitLab');
      }

      if (expectingOk && !res.ok) {
        const isJSON = expectingFormat === 'json';
        throw new _netlifyCmsLibUtil.APIError(isJSON && body.message ? body.message : body, res.status, 'GitLab');
      }

      return body;
    });

    _defineProperty(this, "responseToJSON", res => this.parseResponse(res, {
      expectingFormat: 'json'
    }));

    _defineProperty(this, "responseToBlob", res => this.parseResponse(res, {
      expectingFormat: 'blob'
    }));

    _defineProperty(this, "responseToText", res => this.parseResponse(res, {
      expectingFormat: 'text'
    }));

    _defineProperty(this, "requestJSON", req => this.request(req).then(this.responseToJSON));

    _defineProperty(this, "requestText", req => this.request(req).then(this.responseToText));

    _defineProperty(this, "user", () => this.requestJSON('/user'));

    _defineProperty(this, "WRITE_ACCESS", 30);

    _defineProperty(this, "hasWriteAccess", () => this.requestJSON(this.repoURL).then((_ref3) => {
      let {
        permissions
      } = _ref3;
      const {
        project_access,
        group_access
      } = permissions;

      if (project_access && project_access.access_level >= this.WRITE_ACCESS) {
        return true;
      }

      if (group_access && group_access.access_level >= this.WRITE_ACCESS) {
        return true;
      }

      return false;
    }));

    _defineProperty(this, "readFile", async function (path, sha) {
      let {
        ref = _this.branch,
        parseText = true
      } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      const cacheKey = parseText ? "gl.".concat(sha) : "gl.".concat(sha, ".blob");
      const cachedFile = sha ? await _netlifyCmsLibUtil.localForage.getItem(cacheKey) : null;

      if (cachedFile) {
        return cachedFile;
      }

      const result = await _this.request({
        url: "".concat(_this.repoURL, "/repository/files/").concat(encodeURIComponent(path), "/raw"),
        params: {
          ref
        },
        cache: 'no-store'
      }).then(parseText ? _this.responseToText : _this.responseToBlob);

      if (sha) {
        _netlifyCmsLibUtil.localForage.setItem(cacheKey, result);
      }

      return result;
    });

    _defineProperty(this, "getCursorFromHeaders", headers => {
      // indices and page counts are assumed to be zero-based, but the
      // indices and page counts returned from GitLab are one-based
      const index = parseInt(headers.get('X-Page'), 10) - 1;
      const pageCount = parseInt(headers.get('X-Total-Pages'), 10) - 1;
      const pageSize = parseInt(headers.get('X-Per-Page'), 10);
      const count = parseInt(headers.get('X-Total'), 10);
      const links = (0, _netlifyCmsLibUtil.parseLinkHeader)(headers.get('Link'));
      const actions = (0, _immutable.Map)(links).keySeq().flatMap(key => key === 'prev' && index > 0 || key === 'next' && index < pageCount || key === 'first' && index > 0 || key === 'last' && index < pageCount ? [key] : []);
      return _netlifyCmsLibUtil.Cursor.create({
        actions,
        meta: {
          index,
          count,
          pageSize,
          pageCount
        },
        data: {
          links
        }
      });
    });

    _defineProperty(this, "getCursor", (_ref4) => {
      let {
        headers
      } = _ref4;
      return this.getCursorFromHeaders(headers);
    });

    _defineProperty(this, "fetchCursor", req => (0, _flow2.default)([_netlifyCmsLibUtil.unsentRequest.withMethod('HEAD'), this.request, (0, _netlifyCmsLibUtil.then)(this.getCursor)])(req));

    _defineProperty(this, "fetchCursorAndEntries", req => (0, _flow2.default)([_netlifyCmsLibUtil.unsentRequest.withMethod('GET'), this.request, p => Promise.all([p.then(this.getCursor), p.then(this.responseToJSON)]), (0, _netlifyCmsLibUtil.then)((_ref5) => {
      let [cursor, entries] = _ref5;
      return {
        cursor,
        entries
      };
    })])(req));

    _defineProperty(this, "fetchRelativeCursor", async (cursor, action) => this.fetchCursor(cursor.data.links[action]));

    _defineProperty(this, "reversableActions", (0, _immutable.Map)({
      first: 'last',
      last: 'first',
      next: 'prev',
      prev: 'next'
    }));

    _defineProperty(this, "reverseCursor", cursor => {
      const pageCount = cursor.meta.get('pageCount', 0);
      const currentIndex = cursor.meta.get('index', 0);
      const newIndex = pageCount - currentIndex;
      const links = cursor.data.get('links', (0, _immutable.Map)());
      const reversedLinks = links.mapEntries((_ref6) => {
        let [k, v] = _ref6;
        return [this.reversableActions.get(k) || k, v];
      });
      const reversedActions = cursor.actions.map(action => this.reversableActions.get(action) || action);
      return cursor.updateStore(store => store.setIn(['meta', 'index'], newIndex).setIn(['data', 'links'], reversedLinks).set('actions', reversedActions));
    });

    _defineProperty(this, "listFiles", async path => {
      const firstPageCursor = await this.fetchCursor({
        url: "".concat(this.repoURL, "/repository/tree"),
        params: {
          path,
          ref: this.branch
        }
      });
      const lastPageLink = firstPageCursor.data.getIn(['links', 'last']);
      const {
        entries,
        cursor
      } = await this.fetchCursorAndEntries(lastPageLink);
      return {
        files: entries.filter((_ref7) => {
          let {
            type
          } = _ref7;
          return type === 'blob';
        }).reverse(),
        cursor: this.reverseCursor(cursor)
      };
    });

    _defineProperty(this, "traverseCursor", async (cursor, action) => {
      const link = cursor.data.getIn(['links', action]);
      const {
        entries,
        cursor: newCursor
      } = await this.fetchCursorAndEntries(link);
      return {
        entries: entries.filter((_ref8) => {
          let {
            type
          } = _ref8;
          return type === 'blob';
        }).reverse(),
        cursor: this.reverseCursor(newCursor)
      };
    });

    _defineProperty(this, "listAllFiles", async path => {
      const entries = [];
      let {
        cursor,
        entries: initialEntries
      } = await this.fetchCursorAndEntries({
        url: "".concat(this.repoURL, "/repository/tree"),
        // Get the maximum number of entries per page
        params: {
          path,
          ref: this.branch,
          per_page: 100
        }
      });
      entries.push(...initialEntries);

      while (cursor && cursor.actions.has('next')) {
        const link = cursor.data.getIn(['links', 'next']);
        const {
          cursor: newCursor,
          entries: newEntries
        } = await this.fetchCursorAndEntries(link);
        entries.push(...newEntries);
        cursor = newCursor;
      }

      return entries.filter((_ref9) => {
        let {
          type
        } = _ref9;
        return type === 'blob';
      });
    });

    _defineProperty(this, "toBase64", str => Promise.resolve(_jsBase.Base64.encode(str)));

    _defineProperty(this, "fromBase64", str => _jsBase.Base64.decode(str));

    _defineProperty(this, "uploadAndCommit", async (item, _ref10) => {
      let {
        commitMessage,
        updateFile = false,
        branch = this.branch,
        author = this.commitAuthor
      } = _ref10;
      const content = await (0, _result2.default)(item, 'toBase64', (0, _partial2.default)(this.toBase64, item.raw));
      const file_path = item.path.replace(/^\//, '');
      const action = updateFile ? 'update' : 'create';
      const encoding = 'base64';
      const commitParams = {
        branch,
        commit_message: commitMessage,
        actions: [{
          action,
          file_path,
          content,
          encoding
        }]
      };

      if (author) {
        const {
          name,
          email
        } = author;
        commitParams.author_name = name;
        commitParams.author_email = email;
      }

      await this.request({
        url: "".concat(this.repoURL, "/repository/commits"),
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(commitParams)
      });
      return _objectSpread({}, item, {
        uploaded: true
      });
    });

    _defineProperty(this, "persistFiles", (files, _ref11) => {
      let {
        commitMessage,
        newEntry
      } = _ref11;
      return Promise.all(files.map(file => this.uploadAndCommit(file, {
        commitMessage,
        updateFile: newEntry === false
      })));
    });

    _defineProperty(this, "deleteFile", function (path, commit_message) {
      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      const branch = options.branch || _this.branch;
      const commitParams = {
        commit_message,
        branch
      };

      if (_this.commitAuthor) {
        const {
          name,
          email
        } = _this.commitAuthor;
        commitParams.author_name = name;
        commitParams.author_email = email;
      }

      return (0, _flow2.default)([_netlifyCmsLibUtil.unsentRequest.withMethod('DELETE'), // TODO: only send author params if they are defined.
      _netlifyCmsLibUtil.unsentRequest.withParams(commitParams), _this.request])("".concat(_this.repoURL, "/repository/files/").concat(encodeURIComponent(path)));
    });

    this.api_root = config.api_root || 'https://gitlab.com/api/v4';
    this.token = config.token || false;
    this.branch = config.branch || 'master';
    this.repo = config.repo || '';
    this.repoURL = "/projects/".concat(encodeURIComponent(this.repo));
  }

}

exports.default = API;