"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.onlySuccessfulPromises = exports.then = exports.resolvePromiseProperties = exports.filterPromisesWith = exports.filterPromises = void 0;

var _constant = _interopRequireDefault(require("lodash/constant"));

var _filter = _interopRequireDefault(require("lodash/fp/filter"));

var _map = _interopRequireDefault(require("lodash/fp/map"));

var _flow = _interopRequireDefault(require("lodash/flow"));

var _zipObject = _interopRequireDefault(require("lodash/zipObject"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const filterPromises = (arr, filter) => Promise.all(arr.map(entry => Promise.resolve(entry).then(filter))).then(bits => arr.filter(() => bits.shift()));

exports.filterPromises = filterPromises;

const filterPromisesWith = filter => arr => filterPromises(arr, filter);

exports.filterPromisesWith = filterPromisesWith;

const resolvePromiseProperties = obj => {
  // Get the keys which represent promises
  const promiseKeys = Object.keys(obj).filter(key => typeof obj[key].then === 'function');
  const promises = promiseKeys.map(key => obj[key]); // Resolve all promises

  return Promise.all(promises).then(resolvedPromises => // Return a copy of obj with promises overwritten by their
  // resolved values
  Object.assign({}, obj, (0, _zipObject.default)(promiseKeys, resolvedPromises)));
};

exports.resolvePromiseProperties = resolvePromiseProperties;

const then = fn => p => Promise.resolve(p).then(fn);

exports.then = then;
const filterPromiseSymbol = Symbol('filterPromiseSymbol');
const onlySuccessfulPromises = (0, _flow.default)([then((0, _map.default)(p => p.catch((0, _constant.default)(filterPromiseSymbol)))), then(Promise.all.bind(Promise)), then((0, _filter.default)(maybeValue => maybeValue !== filterPromiseSymbol))]);
exports.onlySuccessfulPromises = onlySuccessfulPromises;