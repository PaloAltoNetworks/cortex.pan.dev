"use strict";
/**
 * Copyright (c) 2017-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const copy_webpack_plugin_1 = __importDefault(require("copy-webpack-plugin"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const react_loadable_ssr_addon_1 = __importDefault(require("react-loadable-ssr-addon"));
const webpack_1 = __importDefault(require("webpack"));
const webpack_bundle_analyzer_1 = require("webpack-bundle-analyzer");
const webpack_merge_1 = __importDefault(require("webpack-merge"));
const constants_1 = require("../constants");
const server_1 = require("../server");
const client_1 = require("../webpack/client");
const server_2 = require("../webpack/server");
const utils_1 = require("../webpack/utils");
const CleanWebpackPlugin_1 = __importDefault(require("../webpack/plugins/CleanWebpackPlugin"));
function compile(config) {
    return new Promise((resolve, reject) => {
        const compiler = webpack_1.default(config);
        compiler.run((err, stats) => {
            if (err) {
                reject(err);
            }
            if (stats.hasErrors()) {
                stats.toJson('errors-only').errors.forEach(e => {
                    console.error(e);
                });
                reject(new Error('Failed to compile with errors.'));
            }
            if (stats.hasWarnings()) {
                stats.toJson('errors-warnings').warnings.forEach(warning => {
                    console.warn(warning);
                });
            }
            resolve();
        });
    });
}
function build(siteDir, cliOptions = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        process.env.BABEL_ENV = 'production';
        process.env.NODE_ENV = 'production';
        console.log(chalk_1.default.blue('Creating an optimized production build...'));
        const props = yield server_1.load(siteDir);
        // Apply user webpack config.
        const { outDir, plugins } = props;
        let clientConfig = webpack_merge_1.default(client_1.createClientConfig(props), {
            plugins: [
                // Remove/clean build folders before building bundles.
                new CleanWebpackPlugin_1.default({ verbose: false }),
                // Visualize size of webpack output files with an interactive zoomable treemap.
                cliOptions.bundleAnalyzer && new webpack_bundle_analyzer_1.BundleAnalyzerPlugin(),
                // Generate client manifests file that will be used for server bundle
                new react_loadable_ssr_addon_1.default({
                    filename: 'client-manifest.json',
                }),
            ].filter(Boolean),
        });
        let serverConfig = server_2.createServerConfig(props);
        const staticDir = path_1.default.resolve(siteDir, constants_1.STATIC_DIR_NAME);
        if (fs_extra_1.default.existsSync(staticDir)) {
            serverConfig = webpack_merge_1.default(serverConfig, {
                plugins: [
                    new copy_webpack_plugin_1.default([
                        {
                            from: staticDir,
                            to: outDir,
                        },
                    ]),
                ],
            });
        }
        // Plugin lifecycle - configureWebpack
        plugins.forEach(plugin => {
            const { configureWebpack } = plugin;
            if (!configureWebpack) {
                return;
            }
            clientConfig = utils_1.applyConfigureWebpack(configureWebpack.bind(plugin), // The plugin lifecycle may reference `this`.
            clientConfig, false);
            serverConfig = utils_1.applyConfigureWebpack(configureWebpack.bind(plugin), // The plugin lifecycle may reference `this`.
            serverConfig, true);
        });
        // Run webpack to build JS bundle (client) and static html files (server).
        yield compile([clientConfig, serverConfig]);
        // Remove server.bundle.js because it is useless
        if (serverConfig.output && serverConfig.output.filename) {
            const serverBundle = path_1.default.join(outDir, serverConfig.output.filename);
            fs_extra_1.default.existsSync(serverBundle) && fs_extra_1.default.unlinkSync(serverBundle);
        }
        /* Plugin lifecycle - postBuild */
        yield Promise.all(plugins.map((plugin) => __awaiter(this, void 0, void 0, function* () {
            if (!plugin.postBuild) {
                return;
            }
            yield plugin.postBuild(props);
        })));
        const relativeDir = path_1.default.relative(process.cwd(), outDir);
        console.log(`\n${chalk_1.default.green('Success!')} Generated static files in ${chalk_1.default.cyan(relativeDir)}.\n`);
    });
}
exports.build = build;
