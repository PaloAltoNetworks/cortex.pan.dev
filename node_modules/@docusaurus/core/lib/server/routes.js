"use strict";
/**
 * Copyright (c) 2017-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@docusaurus/utils");
const lodash_1 = __importDefault(require("lodash"));
const querystring_1 = require("querystring");
function getModulePath(target) {
    if (typeof target === 'string') {
        return target;
    }
    const queryStr = target.query ? `?${querystring_1.stringify(target.query)}` : '';
    return `${target.path}${queryStr}`;
}
function loadRoutes(pluginsRouteConfigs) {
    return __awaiter(this, void 0, void 0, function* () {
        const isProd = process.env.NODE_ENV === 'production';
        const routesImports = [
            `import React from 'react';`,
            `import ComponentCreator from '@docusaurus/ComponentCreator';`,
        ];
        const registry = {};
        const routesPaths = ['404.html'];
        const routesChunkNames = {};
        // This is the higher level overview of route code generation
        function generateRouteCode(routeConfig) {
            const { path: routePath, component, modules = {}, routes, exact, } = routeConfig;
            if (!lodash_1.default.isString(routePath) || !component) {
                throw new Error(`Invalid routeConfig (Path must be a string and component is required) \n${JSON.stringify(routeConfig)}`);
            }
            if (!routes) {
                routesPaths.push(routePath);
            }
            function genRouteChunkNames(value, prefix, name) {
                if (!value) {
                    return null;
                }
                if (lodash_1.default.isArray(value)) {
                    return value.map((val, index) => genRouteChunkNames(val, `${index}`, name));
                }
                if (lodash_1.default.isPlainObject(value) && !lodash_1.default.isString(value) && !value.__import) {
                    const newValue = {};
                    Object.keys(value).forEach(key => {
                        newValue[key] = genRouteChunkNames(value[key], key, name);
                    });
                    return newValue;
                }
                const modulePath = getModulePath(value);
                const chunkName = utils_1.genChunkName(modulePath, prefix, name, isProd);
                const loader = `() => import(/* webpackChunkName: '${chunkName}' */ ${JSON.stringify(modulePath)})`;
                registry[chunkName] = {
                    loader,
                    modulePath,
                };
                return chunkName;
            }
            routesChunkNames[routePath] = lodash_1.default.assign(routesChunkNames[routePath], genRouteChunkNames({ component }, 'component', component), genRouteChunkNames(modules, 'module', routePath));
            const routesStr = routes
                ? `routes: [${routes.map(generateRouteCode).join(',')}],`
                : '';
            const exactStr = exact ? `exact: true,` : '';
            return `
{
  path: '${routePath}',
  component: ComponentCreator('${routePath}'),
  ${exactStr}
  ${routesStr}
}`;
        }
        const routes = pluginsRouteConfigs.map(generateRouteCode);
        const notFoundRoute = `
  {
    path: '*',
    component: ComponentCreator('*')
  }`;
        const routesConfig = `
${routesImports.join('\n')}

export default [
  ${routes.join(',')},
  ${notFoundRoute}
];\n`;
        return {
            registry,
            routesConfig,
            routesChunkNames,
            routesPaths,
        };
    });
}
exports.loadRoutes = loadRoutes;
