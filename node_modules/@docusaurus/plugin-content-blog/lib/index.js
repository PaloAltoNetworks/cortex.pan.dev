"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright (c) 2017-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const utils_1 = require("@docusaurus/utils");
const blogUtils_1 = require("./blogUtils");
const DEFAULT_OPTIONS = {
    path: 'blog',
    routeBasePath: 'blog',
    include: ['*.md', '*.mdx'],
    postsPerPage: 10,
    blogListComponent: '@theme/BlogListPage',
    blogPostComponent: '@theme/BlogPostPage',
    blogTagsListComponent: '@theme/BlogTagsListPage',
    blogTagsPostsComponent: '@theme/BlogTagsPostsPage',
    remarkPlugins: [],
    rehypePlugins: [],
    truncateMarker: /<!--\s*(truncate)\s*-->/,
};
function pluginContentBlog(context, opts) {
    const options = Object.assign(Object.assign({}, DEFAULT_OPTIONS), opts);
    const contentPath = path_1.default.resolve(context.siteDir, options.path);
    const dataDir = path_1.default.join(context.generatedFilesDir, 'docusaurus-plugin-content-blog');
    return {
        name: 'docusaurus-plugin-content-blog',
        getPathsToWatch() {
            const { include = [] } = options;
            const globPattern = include.map(pattern => `${contentPath}/${pattern}`);
            return [...globPattern];
        },
        // Fetches blog contents and returns metadata for the necessary routes.
        loadContent() {
            return __awaiter(this, void 0, void 0, function* () {
                const { postsPerPage, routeBasePath } = options;
                const blogPosts = yield blogUtils_1.generateBlogPosts(contentPath, context, options);
                if (!blogPosts) {
                    return null;
                }
                // Colocate next and prev metadata
                blogPosts.forEach((blogPost, index) => {
                    const prevItem = index > 0 ? blogPosts[index - 1] : null;
                    if (prevItem) {
                        blogPost.metadata.prevItem = {
                            title: prevItem.metadata.title,
                            permalink: prevItem.metadata.permalink,
                        };
                    }
                    const nextItem = index < blogPosts.length - 1 ? blogPosts[index + 1] : null;
                    if (nextItem) {
                        blogPost.metadata.nextItem = {
                            title: nextItem.metadata.title,
                            permalink: nextItem.metadata.permalink,
                        };
                    }
                });
                // Blog pagination routes.
                // Example: `/blog`, `/blog/page/1`, `/blog/page/2`
                const totalCount = blogPosts.length;
                const numberOfPages = Math.ceil(totalCount / postsPerPage);
                const { siteConfig: { baseUrl = '' }, } = context;
                const basePageUrl = utils_1.normalizeUrl([baseUrl, routeBasePath]);
                const blogListPaginated = [];
                function blogPaginationPermalink(page) {
                    return page > 0
                        ? utils_1.normalizeUrl([basePageUrl, `page/${page + 1}`])
                        : basePageUrl;
                }
                for (let page = 0; page < numberOfPages; page += 1) {
                    blogListPaginated.push({
                        metadata: {
                            permalink: blogPaginationPermalink(page),
                            page: page + 1,
                            postsPerPage,
                            totalPages: numberOfPages,
                            totalCount,
                            previousPage: page !== 0 ? blogPaginationPermalink(page - 1) : null,
                            nextPage: page < numberOfPages - 1
                                ? blogPaginationPermalink(page + 1)
                                : null,
                        },
                        items: blogPosts
                            .slice(page * postsPerPage, (page + 1) * postsPerPage)
                            .map(item => item.id),
                    });
                }
                const blogTags = {};
                const tagsPath = utils_1.normalizeUrl([basePageUrl, 'tags']);
                blogPosts.forEach(blogPost => {
                    const { tags } = blogPost.metadata;
                    if (!tags || tags.length === 0) {
                        // TODO: Extract tags out into a separate plugin.
                        // eslint-disable-next-line no-param-reassign
                        blogPost.metadata.tags = [];
                        return;
                    }
                    // eslint-disable-next-line no-param-reassign
                    blogPost.metadata.tags = tags.map(tag => {
                        if (typeof tag === 'string') {
                            const normalizedTag = lodash_1.default.kebabCase(tag);
                            const permalink = utils_1.normalizeUrl([tagsPath, normalizedTag]);
                            if (!blogTags[normalizedTag]) {
                                blogTags[normalizedTag] = {
                                    name: tag.toLowerCase(),
                                    items: [],
                                    permalink,
                                };
                            }
                            blogTags[normalizedTag].items.push(blogPost.id);
                            return {
                                label: tag,
                                permalink,
                            };
                        }
                        else {
                            return tag;
                        }
                    });
                });
                const blogTagsListPath = Object.keys(blogTags).length > 0 ? tagsPath : null;
                return {
                    blogPosts,
                    blogListPaginated,
                    blogTags,
                    blogTagsListPath,
                };
            });
        },
        contentLoaded({ content: blogContents, actions, }) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!blogContents) {
                    return;
                }
                const { blogListComponent, blogPostComponent, blogTagsListComponent, blogTagsPostsComponent, } = options;
                const aliasedSource = (source) => `@docusaurus-plugin-content-blog/${path_1.default.relative(dataDir, source)}`;
                const { addRoute, createData } = actions;
                const { blogPosts, blogListPaginated, blogTags, blogTagsListPath, } = blogContents;
                const blogItemsToModules = {};
                // Create routes for blog entries.
                const blogItems = yield Promise.all(blogPosts.map((blogPost) => __awaiter(this, void 0, void 0, function* () {
                    const { id, metadata } = blogPost;
                    const { permalink } = metadata;
                    const metadataPath = yield createData(`${utils_1.docuHash(permalink)}.json`, JSON.stringify(metadata, null, 2));
                    const temp = {
                        metadata,
                        metadataPath,
                    };
                    blogItemsToModules[id] = temp;
                    return temp;
                })));
                blogItems.map(blogItem => {
                    const { metadata, metadataPath } = blogItem;
                    const { source, permalink } = metadata;
                    addRoute({
                        path: permalink,
                        component: blogPostComponent,
                        exact: true,
                        modules: {
                            content: source,
                            metadata: aliasedSource(metadataPath),
                        },
                    });
                });
                // Create routes for blog's paginated list entries.
                yield Promise.all(blogListPaginated.map((listPage) => __awaiter(this, void 0, void 0, function* () {
                    const { metadata, items } = listPage;
                    const { permalink } = metadata;
                    const pageMetadataPath = yield createData(`${utils_1.docuHash(permalink)}.json`, JSON.stringify(metadata, null, 2));
                    addRoute({
                        path: permalink,
                        component: blogListComponent,
                        exact: true,
                        modules: {
                            items: items.map(postID => {
                                const { metadata: postMetadata, metadataPath, } = blogItemsToModules[postID];
                                // To tell routes.js this is an import and not a nested object to recurse.
                                return {
                                    content: {
                                        __import: true,
                                        path: postMetadata.source,
                                        query: {
                                            truncated: true,
                                        },
                                    },
                                    metadata: aliasedSource(metadataPath),
                                };
                            }),
                            metadata: aliasedSource(pageMetadataPath),
                        },
                    });
                })));
                // Tags.
                const tagsModule = {};
                yield Promise.all(Object.keys(blogTags).map((tag) => __awaiter(this, void 0, void 0, function* () {
                    const { name, items, permalink } = blogTags[tag];
                    tagsModule[tag] = {
                        allTagsPath: blogTagsListPath,
                        slug: tag,
                        name,
                        count: items.length,
                        permalink,
                    };
                    const tagsMetadataPath = yield createData(`${utils_1.docuHash(permalink)}.json`, JSON.stringify(tagsModule[tag], null, 2));
                    addRoute({
                        path: permalink,
                        component: blogTagsPostsComponent,
                        exact: true,
                        modules: {
                            items: items.map(postID => {
                                const { metadata: postMetadata, metadataPath, } = blogItemsToModules[postID];
                                return {
                                    content: {
                                        __import: true,
                                        path: postMetadata.source,
                                        query: {
                                            truncated: true,
                                        },
                                    },
                                    metadata: aliasedSource(metadataPath),
                                };
                            }),
                            metadata: aliasedSource(tagsMetadataPath),
                        },
                    });
                })));
                // Only create /tags page if there are tags.
                if (Object.keys(blogTags).length > 0) {
                    const tagsListPath = yield createData(`${utils_1.docuHash(`${blogTagsListPath}-tags`)}.json`, JSON.stringify(tagsModule, null, 2));
                    addRoute({
                        path: blogTagsListPath,
                        component: blogTagsListComponent,
                        exact: true,
                        modules: {
                            tags: aliasedSource(tagsListPath),
                        },
                    });
                }
            });
        },
        configureWebpack(_config, isServer, { getBabelLoader, getCacheLoader }) {
            const { rehypePlugins, remarkPlugins, truncateMarker } = options;
            return {
                resolve: {
                    alias: {
                        '@docusaurus-plugin-content-blog': dataDir,
                    },
                },
                module: {
                    rules: [
                        {
                            test: /(\.mdx?)$/,
                            include: [contentPath],
                            use: [
                                getCacheLoader(isServer),
                                getBabelLoader(isServer),
                                {
                                    loader: '@docusaurus/mdx-loader',
                                    options: {
                                        remarkPlugins,
                                        rehypePlugins,
                                    },
                                },
                                {
                                    loader: path_1.default.resolve(__dirname, './markdownLoader.js'),
                                    options: {
                                        truncateMarker,
                                    },
                                },
                            ].filter(Boolean),
                        },
                    ],
                },
            };
        },
        postBuild({ outDir }) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!options.feedOptions) {
                    return;
                }
                const { feedOptions: { type: feedType }, } = options;
                const feed = yield blogUtils_1.generateBlogFeed(context, options);
                if (!feed) {
                    return;
                }
                let feedTypes = [];
                if (feedType === 'all') {
                    feedTypes = ['rss', 'atom'];
                }
                else {
                    feedTypes.push(feedType);
                }
                yield Promise.all(feedTypes.map(feedType => {
                    const feedPath = path_1.default.join(outDir, options.routeBasePath, `${feedType}.xml`);
                    const feedContent = feedType === 'rss' ? feed.rss2() : feed.atom1();
                    return fs_extra_1.default.writeFile(feedPath, feedContent, err => {
                        if (err) {
                            throw new Error(`Generating ${feedType} feed failed: ${err}`);
                        }
                    });
                }));
            });
        },
    };
}
exports.default = pluginContentBlog;
