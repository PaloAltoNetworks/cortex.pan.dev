"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright (c) 2017-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const fs_extra_1 = __importDefault(require("fs-extra"));
const globby_1 = __importDefault(require("globby"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const utils_1 = require("@docusaurus/utils");
// YYYY-MM-DD-{name}.mdx?
// prefer named capture, but old node version do not support
const FILENAME_PATTERN = /^(\d{4}-\d{1,2}-\d{1,2})-?(.*?).mdx?$/;
function toUrl({ date, link }) {
    return `${date
        .toISOString()
        .substring(0, '2019-01-01'.length)
        .replace(/-/g, '/')}/${link}`;
}
const DEFAULT_OPTIONS = {
    path: 'blog',
    routeBasePath: 'blog',
    include: ['*.md', '*.mdx'],
    postsPerPage: 10,
    blogListComponent: '@theme/BlogListPage',
    blogPostComponent: '@theme/BlogPostPage',
    blogTagsListComponent: '@theme/BlogTagsListPage',
    blogTagsPostsComponent: '@theme/BlogTagsPostsPage',
    remarkPlugins: [],
    rehypePlugins: [],
    truncateMarker: /<!--\s*(truncate)\s*-->/,
};
function pluginContentBlog(context, opts) {
    const options = Object.assign(Object.assign({}, DEFAULT_OPTIONS), opts);
    const contentPath = path_1.default.resolve(context.siteDir, options.path);
    const dataDir = path_1.default.join(context.generatedFilesDir, 'docusaurus-plugin-content-blog');
    return {
        name: 'docusaurus-plugin-content-blog',
        getPathsToWatch() {
            const { include = [] } = options;
            const globPattern = include.map(pattern => `${contentPath}/${pattern}`);
            return [...globPattern];
        },
        // Fetches blog contents and returns metadata for the necessary routes.
        loadContent() {
            return __awaiter(this, void 0, void 0, function* () {
                const { postsPerPage, include, routeBasePath } = options;
                const { siteConfig, siteDir } = context;
                const blogDir = contentPath;
                if (!fs_extra_1.default.existsSync(blogDir)) {
                    return null;
                }
                const { baseUrl = '' } = siteConfig;
                const blogFiles = yield globby_1.default(include, {
                    cwd: blogDir,
                });
                const blogPosts = [];
                yield Promise.all(blogFiles.map((relativeSource) => __awaiter(this, void 0, void 0, function* () {
                    // Cannot use path.join() as it resolves '../' and removes the '@site'. Let webpack loader resolve it.
                    const source = path_1.default.join(blogDir, relativeSource);
                    const aliasedSource = `@site/${path_1.default.relative(siteDir, source)}`;
                    const blogFileName = path_1.default.basename(relativeSource);
                    const fileString = yield fs_extra_1.default.readFile(source, 'utf-8');
                    const { frontMatter, excerpt } = utils_1.parse(fileString);
                    let date;
                    // extract date and title from filename
                    const match = blogFileName.match(FILENAME_PATTERN);
                    let linkName = blogFileName.replace(/\.mdx?$/, '');
                    if (match) {
                        const [, dateString, name] = match;
                        date = new Date(dateString);
                        linkName = name;
                    }
                    // prefer usedefined date
                    if (frontMatter.date) {
                        date = new Date(frontMatter.date);
                    }
                    // use file create time for blog
                    date = date || (yield fs_extra_1.default.stat(source)).birthtime;
                    frontMatter.title = frontMatter.title || linkName;
                    blogPosts.push({
                        id: frontMatter.id || frontMatter.title,
                        metadata: {
                            permalink: utils_1.normalizeUrl([
                                baseUrl,
                                routeBasePath,
                                frontMatter.id || toUrl({ date, link: linkName }),
                            ]),
                            source: aliasedSource,
                            description: frontMatter.description || excerpt,
                            date,
                            tags: frontMatter.tags,
                            title: frontMatter.title,
                        },
                    });
                })));
                blogPosts.sort((a, b) => b.metadata.date.getTime() - a.metadata.date.getTime());
                // Colocate next and prev metadata
                blogPosts.forEach((blogPost, index) => {
                    const prevItem = index > 0 ? blogPosts[index - 1] : null;
                    if (prevItem) {
                        blogPost.metadata.prevItem = {
                            title: prevItem.metadata.title,
                            permalink: prevItem.metadata.permalink,
                        };
                    }
                    const nextItem = index < blogPosts.length - 1 ? blogPosts[index + 1] : null;
                    if (nextItem) {
                        blogPost.metadata.nextItem = {
                            title: nextItem.metadata.title,
                            permalink: nextItem.metadata.permalink,
                        };
                    }
                });
                // Blog pagination routes.
                // Example: `/blog`, `/blog/page/1`, `/blog/page/2`
                const totalCount = blogPosts.length;
                const numberOfPages = Math.ceil(totalCount / postsPerPage);
                const basePageUrl = utils_1.normalizeUrl([baseUrl, routeBasePath]);
                const blogListPaginated = [];
                function blogPaginationPermalink(page) {
                    return page > 0
                        ? utils_1.normalizeUrl([basePageUrl, `page/${page + 1}`])
                        : basePageUrl;
                }
                for (let page = 0; page < numberOfPages; page += 1) {
                    blogListPaginated.push({
                        metadata: {
                            permalink: blogPaginationPermalink(page),
                            page: page + 1,
                            postsPerPage,
                            totalPages: numberOfPages,
                            totalCount,
                            previousPage: page !== 0 ? blogPaginationPermalink(page - 1) : null,
                            nextPage: page < numberOfPages - 1
                                ? blogPaginationPermalink(page + 1)
                                : null,
                        },
                        items: blogPosts
                            .slice(page * postsPerPage, (page + 1) * postsPerPage)
                            .map(item => item.id),
                    });
                }
                const blogTags = {};
                const tagsPath = utils_1.normalizeUrl([basePageUrl, 'tags']);
                blogPosts.forEach(blogPost => {
                    const { tags } = blogPost.metadata;
                    if (!tags || tags.length === 0) {
                        // TODO: Extract tags out into a separate plugin.
                        // eslint-disable-next-line no-param-reassign
                        blogPost.metadata.tags = [];
                        return;
                    }
                    // eslint-disable-next-line no-param-reassign
                    blogPost.metadata.tags = tags.map(tag => {
                        if (typeof tag === 'string') {
                            const normalizedTag = lodash_1.default.kebabCase(tag);
                            const permalink = utils_1.normalizeUrl([tagsPath, normalizedTag]);
                            if (!blogTags[normalizedTag]) {
                                blogTags[normalizedTag] = {
                                    name: tag.toLowerCase(),
                                    items: [],
                                    permalink,
                                };
                            }
                            blogTags[normalizedTag].items.push(blogPost.id);
                            return {
                                label: tag,
                                permalink,
                            };
                        }
                        else {
                            return tag;
                        }
                    });
                });
                const blogTagsListPath = Object.keys(blogTags).length > 0 ? tagsPath : null;
                return {
                    blogPosts,
                    blogListPaginated,
                    blogTags,
                    blogTagsListPath,
                };
            });
        },
        contentLoaded({ content: blogContents, actions, }) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!blogContents) {
                    return;
                }
                const { blogListComponent, blogPostComponent, blogTagsListComponent, blogTagsPostsComponent, } = options;
                const aliasedSource = (source) => `@docusaurus-plugin-content-blog/${path_1.default.relative(dataDir, source)}`;
                const { addRoute, createData } = actions;
                const { blogPosts, blogListPaginated, blogTags, blogTagsListPath, } = blogContents;
                const blogItemsToModules = {};
                // Create routes for blog entries.
                const blogItems = yield Promise.all(blogPosts.map((blogPost) => __awaiter(this, void 0, void 0, function* () {
                    const { id, metadata } = blogPost;
                    const { permalink } = metadata;
                    const metadataPath = yield createData(`${utils_1.docuHash(permalink)}.json`, JSON.stringify(metadata, null, 2));
                    const temp = {
                        metadata,
                        metadataPath,
                    };
                    blogItemsToModules[id] = temp;
                    return temp;
                })));
                blogItems.map(blogItem => {
                    const { metadata, metadataPath } = blogItem;
                    const { source, permalink } = metadata;
                    addRoute({
                        path: permalink,
                        component: blogPostComponent,
                        exact: true,
                        modules: {
                            content: source,
                            metadata: aliasedSource(metadataPath),
                        },
                    });
                });
                // Create routes for blog's paginated list entries.
                yield Promise.all(blogListPaginated.map((listPage) => __awaiter(this, void 0, void 0, function* () {
                    const { metadata, items } = listPage;
                    const { permalink } = metadata;
                    const pageMetadataPath = yield createData(`${utils_1.docuHash(permalink)}.json`, JSON.stringify(metadata, null, 2));
                    addRoute({
                        path: permalink,
                        component: blogListComponent,
                        exact: true,
                        modules: {
                            items: items.map(postID => {
                                const { metadata: postMetadata, metadataPath, } = blogItemsToModules[postID];
                                // To tell routes.js this is an import and not a nested object to recurse.
                                return {
                                    content: {
                                        __import: true,
                                        path: postMetadata.source,
                                        query: {
                                            truncated: true,
                                        },
                                    },
                                    metadata: aliasedSource(metadataPath),
                                };
                            }),
                            metadata: aliasedSource(pageMetadataPath),
                        },
                    });
                })));
                // Tags.
                const tagsModule = {};
                yield Promise.all(Object.keys(blogTags).map((tag) => __awaiter(this, void 0, void 0, function* () {
                    const { name, items, permalink } = blogTags[tag];
                    tagsModule[tag] = {
                        allTagsPath: blogTagsListPath,
                        slug: tag,
                        name,
                        count: items.length,
                        permalink,
                    };
                    const tagsMetadataPath = yield createData(`${utils_1.docuHash(permalink)}.json`, JSON.stringify(tagsModule[tag], null, 2));
                    addRoute({
                        path: permalink,
                        component: blogTagsPostsComponent,
                        exact: true,
                        modules: {
                            items: items.map(postID => {
                                const { metadata: postMetadata, metadataPath, } = blogItemsToModules[postID];
                                return {
                                    content: {
                                        __import: true,
                                        path: postMetadata.source,
                                        query: {
                                            truncated: true,
                                        },
                                    },
                                    metadata: aliasedSource(metadataPath),
                                };
                            }),
                            metadata: aliasedSource(tagsMetadataPath),
                        },
                    });
                })));
                // Only create /tags page if there are tags.
                if (Object.keys(blogTags).length > 0) {
                    const tagsListPath = yield createData(`${utils_1.docuHash(`${blogTagsListPath}-tags`)}.json`, JSON.stringify(tagsModule, null, 2));
                    addRoute({
                        path: blogTagsListPath,
                        component: blogTagsListComponent,
                        exact: true,
                        modules: {
                            tags: aliasedSource(tagsListPath),
                        },
                    });
                }
            });
        },
        configureWebpack(_config, isServer, { getBabelLoader, getCacheLoader }) {
            const { rehypePlugins, remarkPlugins, truncateMarker } = options;
            return {
                resolve: {
                    alias: {
                        '@docusaurus-plugin-content-blog': dataDir,
                    },
                },
                module: {
                    rules: [
                        {
                            test: /(\.mdx?)$/,
                            include: [contentPath],
                            use: [
                                getCacheLoader(isServer),
                                getBabelLoader(isServer),
                                {
                                    loader: '@docusaurus/mdx-loader',
                                    options: {
                                        remarkPlugins,
                                        rehypePlugins,
                                    },
                                },
                                {
                                    loader: path_1.default.resolve(__dirname, './markdownLoader.js'),
                                    options: {
                                        truncateMarker,
                                    },
                                },
                            ].filter(Boolean),
                        },
                    ],
                },
            };
        },
    };
}
exports.default = pluginContentBlog;
