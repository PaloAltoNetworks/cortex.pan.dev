"use strict";
/**
 * Copyright (c) 2017-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const globby_1 = __importDefault(require("globby"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const utils_1 = require("@docusaurus/utils");
const order_1 = __importDefault(require("./order"));
const sidebars_1 = __importDefault(require("./sidebars"));
const metadata_1 = __importDefault(require("./metadata"));
const DEFAULT_OPTIONS = {
    path: 'docs',
    routeBasePath: 'docs',
    include: ['**/*.{md,mdx}'],
    sidebarPath: '',
    docLayoutComponent: '@theme/DocPage',
    docItemComponent: '@theme/DocItem',
    remarkPlugins: [],
    rehypePlugins: [],
    showLastUpdateTime: false,
    showLastUpdateAuthor: false,
};
function pluginContentDocs(context, opts) {
    const options = Object.assign(Object.assign({}, DEFAULT_OPTIONS), opts);
    const contentPath = path_1.default.resolve(context.siteDir, options.path);
    let sourceToPermalink = {};
    const dataDir = path_1.default.join(context.generatedFilesDir, 'docusaurus-plugin-content-docs');
    return {
        name: 'docusaurus-plugin-content-docs',
        getPathsToWatch() {
            const { include = [] } = options;
            const globPattern = include.map(pattern => `${contentPath}/${pattern}`);
            return [...globPattern, options.sidebarPath];
        },
        // Fetches blog contents and returns metadata for the contents.
        loadContent() {
            return __awaiter(this, void 0, void 0, function* () {
                const { include, routeBasePath, sidebarPath, editUrl, showLastUpdateAuthor, showLastUpdateTime, } = options;
                const { siteConfig, siteDir } = context;
                const docsDir = contentPath;
                if (!fs_extra_1.default.existsSync(docsDir)) {
                    return null;
                }
                const loadedSidebars = sidebars_1.default(sidebarPath);
                // Build the docs ordering such as next, previous, category and sidebar.
                const order = order_1.default(loadedSidebars);
                // Prepare metadata container.
                const docsMetadataRaw = {};
                // Metadata for default docs files.
                const docsFiles = yield globby_1.default(include, {
                    cwd: docsDir,
                });
                yield Promise.all(docsFiles.map((source) => __awaiter(this, void 0, void 0, function* () {
                    const metadata = yield metadata_1.default({
                        source,
                        docsDir,
                        order,
                        siteConfig,
                        docsBasePath: routeBasePath,
                        siteDir,
                        editUrl,
                        showLastUpdateAuthor,
                        showLastUpdateTime,
                    });
                    docsMetadataRaw[metadata.id] = metadata;
                })));
                // Construct docsMetadata
                const docsMetadata = {};
                const permalinkToSidebar = {};
                Object.keys(docsMetadataRaw).forEach(currentID => {
                    let previous;
                    let next;
                    const previousID = utils_1.idx(docsMetadataRaw, [currentID, 'previous']);
                    if (previousID) {
                        previous = {
                            title: utils_1.idx(docsMetadataRaw, [previousID, 'title']) || 'Previous',
                            permalink: utils_1.idx(docsMetadataRaw, [previousID, 'permalink']),
                        };
                    }
                    const nextID = utils_1.idx(docsMetadataRaw, [currentID, 'next']);
                    if (nextID) {
                        next = {
                            title: utils_1.idx(docsMetadataRaw, [nextID, 'title']) || 'Next',
                            permalink: utils_1.idx(docsMetadataRaw, [nextID, 'permalink']),
                        };
                    }
                    docsMetadata[currentID] = Object.assign(Object.assign({}, docsMetadataRaw[currentID]), { previous,
                        next });
                    // sourceToPermalink and permalinkToSidebar mapping
                    const { source, permalink, sidebar } = docsMetadataRaw[currentID];
                    sourceToPermalink[source] = permalink;
                    if (sidebar) {
                        permalinkToSidebar[permalink] = sidebar;
                    }
                });
                const convertDocLink = (item) => {
                    const linkID = item.id;
                    const linkMetadata = docsMetadataRaw[linkID];
                    if (!linkMetadata) {
                        throw new Error(`Improper sidebars file, document with id '${linkID}' not found.`);
                    }
                    return {
                        type: 'link',
                        label: linkMetadata.sidebar_label || linkMetadata.title,
                        href: linkMetadata.permalink,
                    };
                };
                const normalizeCategory = (category) => {
                    const items = category.items.map(item => {
                        switch (item.type) {
                            case 'category':
                                return normalizeCategory(item);
                            case 'ref':
                            case 'doc':
                                return convertDocLink(item);
                            case 'link':
                            default:
                                break;
                        }
                        return item;
                    });
                    return Object.assign(Object.assign({}, category), { items });
                };
                // Transform the sidebar so that all sidebar item will be in the form of 'link' or 'category' only
                // This is what will be passed as props to the UI component
                const docsSidebars = Object.entries(loadedSidebars).reduce((acc, [sidebarId, sidebarItemCategories]) => {
                    acc[sidebarId] = sidebarItemCategories.map(sidebarItemCategory => normalizeCategory(sidebarItemCategory));
                    return acc;
                }, {});
                return {
                    docsMetadata,
                    docsDir,
                    docsSidebars,
                    sourceToPermalink,
                    permalinkToSidebar,
                };
            });
        },
        contentLoaded({ content, actions }) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!content || Object.keys(content.docsMetadata).length === 0) {
                    return;
                }
                const { docLayoutComponent, docItemComponent, routeBasePath } = options;
                const { addRoute, createData } = actions;
                const aliasedSource = (source) => `@docusaurus-plugin-content-docs/${path_1.default.relative(dataDir, source)}`;
                const routes = yield Promise.all(Object.values(content.docsMetadata).map((metadataItem) => __awaiter(this, void 0, void 0, function* () {
                    const metadataPath = yield createData(`${utils_1.docuHash(metadataItem.permalink)}.json`, JSON.stringify(metadataItem, null, 2));
                    return {
                        path: metadataItem.permalink,
                        component: docItemComponent,
                        exact: true,
                        modules: {
                            content: metadataItem.source,
                            metadata: aliasedSource(metadataPath),
                        },
                    };
                })));
                const docsBaseMetadata = {
                    docsSidebars: content.docsSidebars,
                    permalinkToSidebar: content.permalinkToSidebar,
                };
                const docsBaseRoute = utils_1.normalizeUrl([
                    context.baseUrl,
                    routeBasePath,
                    ':route',
                ]);
                const docsBaseMetadataPath = yield createData(`${utils_1.docuHash(docsBaseRoute)}.json`, JSON.stringify(docsBaseMetadata, null, 2));
                addRoute({
                    path: docsBaseRoute,
                    component: docLayoutComponent,
                    routes,
                    modules: {
                        docsMetadata: aliasedSource(docsBaseMetadataPath),
                    },
                });
            });
        },
        configureWebpack(_, isServer, utils) {
            const { getBabelLoader, getCacheLoader } = utils;
            const { rehypePlugins, remarkPlugins } = options;
            return {
                resolve: {
                    alias: {
                        '@docusaurus-plugin-content-docs': dataDir,
                    },
                },
                module: {
                    rules: [
                        {
                            test: /(\.mdx?)$/,
                            include: [contentPath],
                            use: [
                                getCacheLoader(isServer),
                                getBabelLoader(isServer),
                                {
                                    loader: '@docusaurus/mdx-loader',
                                    options: {
                                        remarkPlugins,
                                        rehypePlugins,
                                    },
                                },
                                {
                                    loader: path_1.default.resolve(__dirname, './markdown/index.js'),
                                    options: {
                                        siteDir: context.siteDir,
                                        docsDir: contentPath,
                                        sourceToPermalink: sourceToPermalink,
                                    },
                                },
                            ].filter(Boolean),
                        },
                    ],
                },
            };
        },
    };
}
exports.default = pluginContentDocs;
