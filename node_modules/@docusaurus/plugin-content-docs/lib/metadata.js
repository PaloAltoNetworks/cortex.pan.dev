"use strict";
/**
 * Copyright (c) 2017-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const utils_1 = require("@docusaurus/utils");
const lastUpdate_1 = __importDefault(require("./lastUpdate"));
function processMetadata({ source, docsDir, order, siteConfig, docsBasePath, siteDir, editUrl, showLastUpdateAuthor, showLastUpdateTime, }) {
    return __awaiter(this, void 0, void 0, function* () {
        const filePath = path_1.default.join(docsDir, source);
        const fileString = yield fs_extra_1.default.readFile(filePath, 'utf-8');
        const { frontMatter: metadata = {}, excerpt } = utils_1.parse(fileString);
        // Default id is the file name.
        if (!metadata.id) {
            metadata.id = path_1.default.basename(source, path_1.default.extname(source));
        }
        if (metadata.id.includes('/')) {
            throw new Error('Document id cannot include "/".');
        }
        // Default title is the id.
        if (!metadata.title) {
            metadata.title = metadata.id;
        }
        if (!metadata.description) {
            metadata.description = excerpt;
        }
        const dirName = path_1.default.dirname(source);
        if (dirName !== '.') {
            const prefix = dirName;
            if (prefix) {
                metadata.id = `${prefix}/${metadata.id}`;
            }
        }
        // Cannot use path.join() as it resolves '../' and removes the '@site'. Let webpack loader resolve it.
        const aliasedPath = `@site/${path_1.default.relative(siteDir, filePath)}`;
        metadata.source = aliasedPath;
        // Build the permalink.
        const { baseUrl } = siteConfig;
        // If user has own custom permalink defined in frontmatter
        // e.g: :baseUrl:docsUrl/:langPart/:versionPart/endiliey/:id
        if (metadata.permalink) {
            metadata.permalink = path_1.default.resolve(metadata.permalink
                .replace(/:baseUrl/, baseUrl)
                .replace(/:docsUrl/, docsBasePath)
                .replace(/:id/, metadata.id));
        }
        else {
            metadata.permalink = utils_1.normalizeUrl([baseUrl, docsBasePath, metadata.id]);
        }
        // Determine order.
        const { id } = metadata;
        if (order[id]) {
            metadata.sidebar = order[id].sidebar;
            if (order[id].next) {
                metadata.next = order[id].next;
            }
            if (order[id].previous) {
                metadata.previous = order[id].previous;
            }
        }
        if (editUrl) {
            metadata.editUrl = utils_1.normalizeUrl([editUrl, source]);
        }
        if (metadata.custom_edit_url) {
            metadata.editUrl = metadata.custom_edit_url;
            delete metadata.custom_edit_url;
        }
        if (showLastUpdateAuthor || showLastUpdateTime) {
            // Use fake data in dev for faster development
            const fileLastUpdateData = process.env.NODE_ENV === 'production'
                ? lastUpdate_1.default(filePath)
                : {
                    author: 'Author',
                    timestamp: '1539502055',
                };
            if (fileLastUpdateData) {
                const { author, timestamp } = fileLastUpdateData;
                if (showLastUpdateAuthor && author) {
                    metadata.lastUpdatedBy = author;
                }
                if (showLastUpdateTime && timestamp) {
                    metadata.lastUpdatedAt = timestamp;
                }
            }
        }
        return metadata;
    });
}
exports.default = processMetadata;
