"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

var _trimStart = _interopRequireDefault(require("lodash/trimStart"));

var _semaphore = _interopRequireDefault(require("semaphore"));

var _commonTags = require("common-tags");

var _netlifyCmsLibUtil = require("netlify-cms-lib-util");

var _AuthenticationPage = _interopRequireDefault(require("./AuthenticationPage"));

var _API = _interopRequireDefault(require("./API"));

var _GraphQLAPI = _interopRequireDefault(require("./GraphQLAPI"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _templateObject() {
  const data = _taggedTemplateLiteral(["\n        Repo \"", "\" not found.\n\n        Please ensure the repo information is spelled correctly.\n\n        If the repo is private, make sure you're logged into a GitHub account with access.\n\n        If your repo is under an organization, ensure the organization has granted access to Netlify\n        CMS.\n      "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const MAX_CONCURRENT_DOWNLOADS = 10;
/**
 * Keywords for inferring a status that will provide a deploy preview URL.
 */

const PREVIEW_CONTEXT_KEYWORDS = ['deploy'];
/**
 * Check a given status context string to determine if it provides a link to a
 * deploy preview. Checks for an exact match against `previewContext` if given,
 * otherwise checks for inclusion of a value from `PREVIEW_CONTEXT_KEYWORDS`.
 */

function isPreviewContext(context, previewContext) {
  if (previewContext) {
    return context === previewContext;
  }

  return PREVIEW_CONTEXT_KEYWORDS.some(keyword => context.includes(keyword));
}
/**
 * Retrieve a deploy preview URL from an array of statuses. By default, a
 * matching status is inferred via `isPreviewContext`.
 */


function getPreviewStatus(statuses, config) {
  const previewContext = config.getIn(['backend', 'preview_context']);
  return statuses.find((_ref) => {
    let {
      context
    } = _ref;
    return isPreviewContext(context, previewContext);
  });
}

class GitHub {
  constructor(config) {
    var _this = this;

    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _defineProperty(this, "fetchFiles", function (files) {
      let {
        repoURL = _this.api.repoURL
      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      const sem = (0, _semaphore.default)(MAX_CONCURRENT_DOWNLOADS);
      const promises = [];
      files.forEach(file => {
        promises.push(new Promise(resolve => sem.take(() => _this.api.readFile(file.path, file.sha, {
          repoURL
        }).then(data => {
          resolve({
            file,
            data
          });
          sem.leave();
        }).catch(function () {
          let err = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
          sem.leave();
          console.error("failed to load file from GitHub: ".concat(file.path));
          resolve({
            error: err
          });
        }))));
      });
      return Promise.all(promises).then(loadedEntries => loadedEntries.filter(loadedEntry => !loadedEntry.error));
    });

    this.config = config;
    this.options = _objectSpread({
      proxied: false,
      API: null
    }, options);

    if (!this.options.proxied && config.getIn(['backend', 'repo']) == null) {
      throw new Error('The GitHub backend needs a "repo" in the backend configuration.');
    }

    this.api = this.options.API || null;
    this.openAuthoringEnabled = config.getIn(['backend', 'open_authoring'], false);

    if (this.openAuthoringEnabled) {
      if (!this.options.useWorkflow) {
        throw new Error('backend.open_authoring is true but publish_mode is not set to editorial_workflow.');
      }

      this.originRepo = config.getIn(['backend', 'repo'], '');
    } else {
      this.repo = this.originRepo = config.getIn(['backend', 'repo'], '');
    }

    this.branch = config.getIn(['backend', 'branch'], 'master').trim();
    this.api_root = config.getIn(['backend', 'api_root'], 'https://api.github.com');
    this.token = '';
    this.squash_merges = config.getIn(['backend', 'squash_merges']);
    this.use_graphql = config.getIn(['backend', 'use_graphql']);
    this.lock = (0, _netlifyCmsLibUtil.asyncLock)();
  }

  async runWithLock(func, message) {
    try {
      const acquired = await this.lock.acquire();

      if (!acquired) {
        console.warn(message);
      }

      const result = await func();
      return result;
    } finally {
      this.lock.release();
    }
  }

  authComponent() {
    const wrappedAuthenticationPage = props => _react.default.createElement(_AuthenticationPage.default, _extends({}, props, {
      backend: this
    }));

    wrappedAuthenticationPage.displayName = 'AuthenticationPage';
    return wrappedAuthenticationPage;
  }

  restoreUser(user) {
    return this.openAuthoringEnabled ? this.authenticateWithFork({
      userData: user,
      getPermissionToFork: () => true
    }).then(() => this.authenticate(user)) : this.authenticate(user);
  }

  async pollUntilForkExists(_ref2) {
    let {
      repo,
      token
    } = _ref2;
    const pollDelay = 250; // milliseconds

    var repoExists = false;

    while (!repoExists) {
      repoExists = await fetch("".concat(this.api_root, "/repos/").concat(repo), {
        headers: {
          Authorization: "token ".concat(token)
        }
      }).then(() => true).catch(err => err && err.status === 404 ? false : Promise.reject(err)); // wait between polls

      if (!repoExists) {
        await new Promise(resolve => setTimeout(resolve, pollDelay));
      }
    }

    return Promise.resolve();
  }

  async currentUser(_ref3) {
    let {
      token
    } = _ref3;

    if (!this._currentUserPromise) {
      this._currentUserPromise = fetch("".concat(this.api_root, "/user"), {
        headers: {
          Authorization: "token ".concat(token)
        }
      }).then(res => res.json());
    }

    return this._currentUserPromise;
  }

  async userIsOriginMaintainer(_ref4) {
    let {
      username: usernameArg,
      token
    } = _ref4;
    const username = usernameArg || (await this.currentUser({
      token
    })).login;
    this._userIsOriginMaintainerPromises = this._userIsOriginMaintainerPromises || {};

    if (!this._userIsOriginMaintainerPromises[username]) {
      this._userIsOriginMaintainerPromises[username] = fetch("".concat(this.api_root, "/repos/").concat(this.originRepo, "/collaborators/").concat(username, "/permission"), {
        headers: {
          Authorization: "token ".concat(token)
        }
      }).then(res => res.json()).then((_ref5) => {
        let {
          permission
        } = _ref5;
        return permission === 'admin' || permission === 'write';
      });
    }

    return this._userIsOriginMaintainerPromises[username];
  }

  async forkExists(_ref6) {
    let {
      token
    } = _ref6;

    try {
      const currentUser = await this.currentUser({
        token
      });
      const repoName = this.originRepo.split('/')[1];
      const repo = await fetch("".concat(this.api_root, "/repos/").concat(currentUser.login, "/").concat(repoName), {
        method: 'GET',
        headers: {
          Authorization: "token ".concat(token)
        }
      }).then(res => res.json()); // https://developer.github.com/v3/repos/#get
      // The parent and source objects are present when the repository is a fork.
      // parent is the repository this repository was forked from, source is the ultimate source for the network.

      const forkExists = repo.fork === true && repo.parent && repo.parent.full_name === this.originRepo;
      return forkExists;
    } catch (_unused) {
      return false;
    }
  }

  async authenticateWithFork(_ref7) {
    let {
      userData,
      getPermissionToFork
    } = _ref7;

    if (!this.openAuthoringEnabled) {
      throw new Error('Cannot authenticate with fork; Open Authoring is turned off.');
    }

    const {
      token
    } = userData; // Origin maintainers should be able to use the CMS normally

    if (await this.userIsOriginMaintainer({
      token
    })) {
      this.repo = this.originRepo;
      this.useOpenAuthoring = false;
      return Promise.resolve();
    }

    if (!(await this.forkExists({
      token
    }))) {
      await getPermissionToFork();
    }

    const fork = await fetch("".concat(this.api_root, "/repos/").concat(this.originRepo, "/forks"), {
      method: 'POST',
      headers: {
        Authorization: "token ".concat(token)
      }
    }).then(res => res.json());
    this.useOpenAuthoring = true;
    this.repo = fork.full_name;
    return this.pollUntilForkExists({
      repo: fork.full_name,
      token
    });
  }

  async authenticate(state) {
    this.token = state.token;
    const apiCtor = this.use_graphql ? _GraphQLAPI.default : _API.default;
    this.api = new apiCtor({
      token: this.token,
      branch: this.branch,
      repo: this.repo,
      originRepo: this.originRepo,
      api_root: this.api_root,
      squash_merges: this.squash_merges,
      useOpenAuthoring: this.useOpenAuthoring,
      initialWorkflowStatus: this.options.initialWorkflowStatus
    });
    const user = await this.api.user();
    const isCollab = await this.api.hasWriteAccess().catch(error => {
      error.message = (0, _commonTags.stripIndent)(_templateObject(), this.repo);
      throw error;
    }); // Unauthorized user

    if (!isCollab) {
      throw new Error('Your GitHub user account does not have access to this repo.');
    } // Authorized user


    return _objectSpread({}, user, {
      token: state.token,
      useOpenAuthoring: this.useOpenAuthoring
    });
  }

  logout() {
    this.token = null;

    if (this.api && typeof this.api.reset === 'function') {
      return this.api.reset();
    }

    return;
  }

  getToken() {
    return Promise.resolve(this.token);
  }

  async entriesByFolder(collection, extension) {
    const repoURL = this.useOpenAuthoring ? this.api.originRepoURL : this.api.repoURL;
    const files = await this.api.listFiles(collection.get('folder'), {
      repoURL
    });
    const filteredFiles = files.filter(file => file.name.endsWith('.' + extension));
    return this.fetchFiles(filteredFiles, {
      repoURL
    });
  }

  entriesByFiles(collection) {
    const repoURL = this.useOpenAuthoring ? this.api.originRepoURL : this.api.repoURL;
    const files = collection.get('files').map(collectionFile => ({
      path: collectionFile.get('file'),
      label: collectionFile.get('label')
    }));
    return this.fetchFiles(files, {
      repoURL
    });
  }

  // Fetches a single entry.
  getEntry(collection, slug, path) {
    const repoURL = this.api.originRepoURL;
    return this.api.readFile(path, null, {
      repoURL
    }).then(data => ({
      file: {
        path
      },
      data
    }));
  }

  getMedia() {
    return this.api.listFiles(this.config.get('media_folder')).then(files => files.map((_ref8) => {
      let {
        sha,
        name,
        size,
        path
      } = _ref8;
      // load media using getMediaDisplayURL to avoid token expiration with GitHub raw content urls
      // for private repositories
      return {
        id: sha,
        name,
        size,
        displayURL: {
          sha,
          path
        },
        path
      };
    }));
  }

  async getMediaDisplayURL(displayURL) {
    const {
      sha,
      path
    } = displayURL;
    const mediaURL = await this.api.getMediaDisplayURL(sha, path);
    return mediaURL;
  }

  persistEntry(entry) {
    let mediaFiles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    // persistEntry is a transactional operation
    return this.runWithLock(() => this.api.persistFiles(entry, mediaFiles, options), 'Failed to acquire persist entry lock');
  }

  async persistMedia(mediaFile) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    try {
      await this.api.persistFiles(null, [mediaFile], options);
      const {
        sha,
        value,
        path,
        fileObj
      } = mediaFile;
      const displayURL = URL.createObjectURL(fileObj);
      return {
        id: sha,
        name: value,
        size: fileObj.size,
        displayURL,
        path: (0, _trimStart.default)(path, '/')
      };
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  deleteFile(path, commitMessage, options) {
    return this.api.deleteFile(path, commitMessage, options);
  }

  unpublishedEntries() {
    return this.api.listUnpublishedBranches().then(branches => {
      const sem = (0, _semaphore.default)(MAX_CONCURRENT_DOWNLOADS);
      const promises = [];
      branches.map((_ref9) => {
        let {
          ref
        } = _ref9;
        promises.push(new Promise(resolve => {
          const contentKey = ref.split('refs/heads/cms/').pop();
          const slug = contentKey.split('/').pop();
          return sem.take(() => this.api.readUnpublishedBranchFile(contentKey).then(data => {
            if (data === null || data === undefined) {
              resolve(null);
              sem.leave();
            } else {
              const path = data.metaData.objects.entry.path;
              resolve({
                slug,
                file: {
                  path
                },
                data: data.fileData,
                metaData: data.metaData,
                isModification: data.isModification
              });
              sem.leave();
            }
          }).catch(() => {
            sem.leave();
            resolve(null);
          }));
        }));
      });
      return Promise.all(promises);
    }).catch(error => {
      if (error.message === 'Not Found') {
        return Promise.resolve([]);
      }

      return Promise.reject(error);
    });
  }

  unpublishedEntry(collection, slug) {
    const contentKey = this.api.generateContentKey(collection.get('name'), slug);
    return this.api.readUnpublishedBranchFile(contentKey).then(data => {
      if (!data) return null;
      return {
        slug,
        file: {
          path: data.metaData.objects.entry.path
        },
        data: data.fileData,
        metaData: data.metaData,
        isModification: data.isModification
      };
    });
  }
  /**
   * Uses GitHub's Statuses API to retrieve statuses, infers which is for a
   * deploy preview via `getPreviewStatus`. Returns the url provided by the
   * status, as well as the status state, which should be one of 'success',
   * 'pending', and 'failure'.
   */


  async getDeployPreview(collection, slug) {
    const contentKey = this.api.generateContentKey(collection.get('name'), slug);
    const data = await this.api.retrieveMetadata(contentKey);

    if (!data || !data.pr) {
      return null;
    }

    const headSHA = typeof data.pr.head === 'string' ? data.pr.head : data.pr.head.sha;
    const statuses = await this.api.getStatuses(headSHA);
    const deployStatus = getPreviewStatus(statuses, this.config);

    if (deployStatus) {
      const {
        target_url,
        state
      } = deployStatus;
      return {
        url: target_url,
        status: state
      };
    }
  }

  updateUnpublishedEntryStatus(collection, slug, newStatus) {
    // updateUnpublishedEntryStatus is a transactional operation
    return this.runWithLock(() => this.api.updateUnpublishedEntryStatus(collection, slug, newStatus), 'Failed to acquire update entry status lock');
  }

  deleteUnpublishedEntry(collection, slug) {
    // deleteUnpublishedEntry is a transactional operation
    return this.runWithLock(() => this.api.deleteUnpublishedEntry(collection, slug), 'Failed to acquire delete entry lock');
  }

  publishUnpublishedEntry(collection, slug) {
    // publishUnpublishedEntry is a transactional operation
    return this.runWithLock(() => this.api.publishUnpublishedEntry(collection, slug), 'Failed to acquire publish entry lock');
  }

}

exports.default = GitHub;