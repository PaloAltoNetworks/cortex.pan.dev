"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _apolloClient = require("apollo-client");

var _apolloCacheInmemory = require("apollo-cache-inmemory");

var _apolloLinkHttp = require("apollo-link-http");

var _apolloLinkContext = require("apollo-link-context");

var _netlifyCmsLibUtil = require("netlify-cms-lib-util");

var _fragmentTypes = _interopRequireDefault(require("./fragmentTypes"));

var _API = _interopRequireDefault(require("./API"));

var queries = _interopRequireWildcard(require("./queries"));

var mutations = _interopRequireWildcard(require("./mutations"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const NO_CACHE = 'no-cache';
const CACHE_FIRST = 'cache-first';
const TREE_ENTRY_TYPE_TO_MODE = {
  blob: '100644',
  tree: '040000',
  commit: '160000'
};
const fragmentMatcher = new _apolloCacheInmemory.IntrospectionFragmentMatcher({
  introspectionQueryResultData: _fragmentTypes.default
});

class GraphQLAPI extends _API.default {
  constructor(config) {
    super(config);
    const [repoParts, originRepoParts] = [this.repo.split('/'), this.originRepo.split('/')];
    this.repo_owner = repoParts[0];
    this.repo_name = repoParts[1];
    this.origin_repo_owner = originRepoParts[0];
    this.origin_repo_name = originRepoParts[1];
    this.client = this.getApolloClient();
  }

  getApolloClient() {
    const authLink = (0, _apolloLinkContext.setContext)((_, _ref) => {
      let {
        headers
      } = _ref;
      return {
        headers: _objectSpread({}, headers, {
          authorization: this.token ? "token ".concat(this.token) : ''
        })
      };
    });
    const httpLink = (0, _apolloLinkHttp.createHttpLink)({
      uri: "".concat(this.api_root, "/graphql")
    });
    return new _apolloClient.ApolloClient({
      link: authLink.concat(httpLink),
      cache: new _apolloCacheInmemory.InMemoryCache({
        fragmentMatcher
      }),
      defaultOptions: {
        watchQuery: {
          fetchPolicy: NO_CACHE,
          errorPolicy: 'ignore'
        },
        query: {
          fetchPolicy: NO_CACHE,
          errorPolicy: 'all'
        }
      }
    });
  }

  reset() {
    return this.client.resetStore();
  }

  async getRepository(owner, name) {
    const {
      data
    } = await this.query({
      query: queries.repository,
      variables: {
        owner,
        name
      },
      fetchPolicy: CACHE_FIRST // repository id doesn't change

    });
    return data.repository;
  }

  query() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return this.client.query(options).catch(error => {
      throw new _netlifyCmsLibUtil.APIError(error.message, 500, 'GitHub');
    });
  }

  mutate() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return this.client.mutate(options).catch(error => {
      throw new _netlifyCmsLibUtil.APIError(error.message, 500, 'GitHub');
    });
  }

  async hasWriteAccess() {
    const {
      repo_owner: owner,
      repo_name: name
    } = this;

    try {
      const {
        data
      } = await this.query({
        query: queries.repoPermission,
        variables: {
          owner,
          name
        },
        fetchPolicy: CACHE_FIRST // we can assume permission doesn't change often

      }); // https://developer.github.com/v4/enum/repositorypermission/

      const {
        viewerPermission
      } = data.repository;
      return ['ADMIN', 'MAINTAIN', 'WRITE'].includes(viewerPermission);
    } catch (error) {
      console.error('Problem fetching repo data from GitHub');
      throw error;
    }
  }

  async user() {
    const {
      data
    } = await this.query({
      query: queries.user,
      fetchPolicy: CACHE_FIRST // we can assume user details don't change often

    });
    return data.viewer;
  }

  async retrieveBlobObject(owner, name, expression) {
    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    const {
      data
    } = await this.query(_objectSpread({
      query: queries.blob,
      variables: {
        owner,
        name,
        expression
      }
    }, options)); // https://developer.github.com/v4/object/blob/

    if (data.repository.object) {
      const {
        is_binary,
        text
      } = data.repository.object;
      return {
        is_null: false,
        is_binary,
        text
      };
    } else {
      return {
        is_null: true
      };
    }
  }

  getOwnerAndNameFromRepoUrl(repoURL) {
    let {
      repo_owner: owner,
      repo_name: name
    } = this;

    if (repoURL === this.originRepoURL) {
      ({
        origin_repo_owner: owner,
        origin_repo_name: name
      } = this);
    }

    return {
      owner,
      name
    };
  }

  async retrieveContent(path, branch, repoURL) {
    const {
      owner,
      name
    } = this.getOwnerAndNameFromRepoUrl(repoURL);
    const {
      is_null,
      is_binary,
      text
    } = await this.retrieveBlobObject(owner, name, "".concat(branch, ":").concat(path));

    if (is_null) {
      throw new _netlifyCmsLibUtil.APIError('Not Found', 404, 'GitHub');
    } else if (!is_binary) {
      return text;
    } else {
      return super.retrieveContent(path, branch, repoURL);
    }
  }

  async fetchBlobContent(sha, repoURL) {
    const {
      owner,
      name
    } = this.getOwnerAndNameFromRepoUrl(repoURL);
    const {
      is_null,
      is_binary,
      text
    } = await this.retrieveBlobObject(owner, name, sha, {
      fetchPolicy: CACHE_FIRST
    } // blob sha is derived from file content
    );

    if (is_null) {
      throw new _netlifyCmsLibUtil.APIError('Not Found', 404, 'GitHub');
    } else if (!is_binary) {
      return text;
    } else {
      return super.fetchBlobContent(sha, repoURL);
    }
  }

  async getStatuses(sha) {
    const {
      origin_repo_owner: owner,
      origin_repo_name: name
    } = this;
    const {
      data
    } = await this.query({
      query: queries.statues,
      variables: {
        owner,
        name,
        sha
      }
    });

    if (data.repository.object) {
      const {
        status
      } = data.repository.object;
      const {
        contexts
      } = status || {
        contexts: []
      };
      return contexts;
    } else {
      return [];
    }
  }

  async listFiles(path) {
    let {
      repoURL = this.repoURL,
      branch = this.branch
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const {
      owner,
      name
    } = this.getOwnerAndNameFromRepoUrl(repoURL);
    const {
      data
    } = await this.query({
      query: queries.files,
      variables: {
        owner,
        name,
        expression: "".concat(branch, ":").concat(path)
      }
    });

    if (data.repository.object) {
      const files = data.repository.object.entries.filter((_ref2) => {
        let {
          type
        } = _ref2;
        return type === 'blob';
      }).map(e => _objectSpread({}, e, {
        path: "".concat(path, "/").concat(e.name),
        size: e.blob && e.blob.size
      }));
      return files;
    } else {
      throw new _netlifyCmsLibUtil.APIError('Not Found', 404, 'GitHub');
    }
  }

  async listUnpublishedBranches() {
    if (this.useOpenAuthoring) {
      return super.listUnpublishedBranches();
    }

    console.log('%c Checking for Unpublished entries', 'line-height: 30px;text-align: center;font-weight: bold');
    const {
      repo_owner: owner,
      repo_name: name
    } = this;
    const {
      data
    } = await this.query({
      query: queries.unpublishedPrBranches,
      variables: {
        owner,
        name
      }
    });
    const {
      nodes
    } = data.repository.refs;

    if (nodes.length > 0) {
      const branches = [];
      nodes.forEach((_ref3) => {
        let {
          associatedPullRequests
        } = _ref3;
        associatedPullRequests.nodes.forEach((_ref4) => {
          let {
            headRef
          } = _ref4;
          branches.push({
            ref: "".concat(headRef.prefix).concat(headRef.name)
          });
        });
      });
      return branches;
    } else {
      console.log('%c No Unpublished entries', 'line-height: 30px;text-align: center;font-weight: bold');
      throw new _netlifyCmsLibUtil.APIError('Not Found', 404, 'GitHub');
    }
  }

  async readUnpublishedBranchFile(contentKey) {
    // retrieveMetadata(contentKey) rejects in case of no metadata
    const metaData = await this.retrieveMetadata(contentKey).catch(() => null);

    if (metaData && metaData.objects && metaData.objects.entry && metaData.objects.entry.path) {
      const {
        path
      } = metaData.objects.entry;
      const {
        repo_owner: headOwner,
        repo_name: headRepoName
      } = this;
      const {
        origin_repo_owner: baseOwner,
        origin_repo_name: baseRepoName
      } = this;
      const {
        data
      } = await this.query({
        query: queries.unpublishedBranchFile,
        variables: {
          headOwner,
          headRepoName,
          headExpression: "".concat(metaData.branch, ":").concat(path),
          baseOwner,
          baseRepoName,
          baseExpression: "".concat(this.branch, ":").concat(path)
        }
      });

      if (!data.head.object) {
        throw new _netlifyCmsLibUtil.EditorialWorkflowError('content is not under editorial workflow', true);
      }

      const result = {
        metaData,
        fileData: data.head.object.text,
        isModification: !!data.base.object
      };
      return result;
    } else {
      throw new _netlifyCmsLibUtil.EditorialWorkflowError('content is not under editorial workflow', true);
    }
  }

  getBranchQualifiedName(branch) {
    return "refs/heads/".concat(branch);
  }

  getBranchQuery(branch) {
    const {
      repo_owner: owner,
      repo_name: name
    } = this;
    return {
      query: queries.branch,
      variables: {
        owner,
        name,
        qualifiedName: this.getBranchQualifiedName(branch)
      }
    };
  }

  async getBranch() {
    let branch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.branch;
    // don't cache base branch to always get the latest data
    const fetchPolicy = branch === this.branch ? NO_CACHE : CACHE_FIRST;
    const {
      data
    } = await this.query(_objectSpread({}, this.getBranchQuery(branch), {
      fetchPolicy
    }));
    return data.repository.branch;
  }

  async patchRef(type, name, sha) {
    let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    if (type !== 'heads') {
      return super.patchRef(type, name, sha, opts);
    }

    const force = opts.force || false;
    const branch = await this.getBranch(name);
    const {
      data
    } = await this.mutate({
      mutation: mutations.updateBranch,
      variables: {
        input: {
          oid: sha,
          refId: branch.id,
          force
        }
      }
    });
    return data.updateRef.branch;
  }

  async deleteBranch(branchName) {
    const branch = await this.getBranch(branchName);
    const {
      data
    } = await this.mutate({
      mutation: mutations.deleteBranch,
      variables: {
        deleteRefInput: {
          refId: branch.id
        }
      },
      update: store => store.data.delete((0, _apolloCacheInmemory.defaultDataIdFromObject)(branch))
    });
    return data.deleteRef;
  }

  getPullRequestQuery(number) {
    const {
      origin_repo_owner: owner,
      origin_repo_name: name
    } = this;
    return {
      query: queries.pullRequest,
      variables: {
        owner,
        name,
        number
      }
    };
  }

  async getPullRequest(number) {
    const {
      data
    } = await this.query(_objectSpread({}, this.getPullRequestQuery(number), {
      fetchPolicy: CACHE_FIRST
    })); // https://developer.github.com/v4/enum/pullrequeststate/
    // GraphQL state: [CLOSED, MERGED, OPEN]
    // REST API state: [closed, open]

    const state = data.repository.pullRequest.state === 'OPEN' ? 'open' : 'closed';
    return _objectSpread({}, data.repository.pullRequest, {
      state
    });
  }

  getPullRequestAndBranchQuery(branch, number) {
    const {
      repo_owner: owner,
      repo_name: name
    } = this;
    const {
      origin_repo_owner: origin_owner,
      origin_repo_name: origin_name
    } = this;
    return {
      query: queries.pullRequestAndBranch,
      variables: {
        owner,
        name,
        origin_owner,
        origin_name,
        number,
        qualifiedName: this.getBranchQualifiedName(branch)
      }
    };
  }

  async getPullRequestAndBranch(branch, number) {
    const {
      data
    } = await this.query(_objectSpread({}, this.getPullRequestAndBranchQuery(branch, number), {
      fetchPolicy: CACHE_FIRST
    }));
    const {
      repository,
      origin
    } = data;
    return {
      branch: repository.branch,
      pullRequest: origin.pullRequest
    };
  }

  async openPR(_ref5) {
    let {
      number
    } = _ref5;
    const pullRequest = await this.getPullRequest(number);
    const {
      data
    } = await this.mutate({
      mutation: mutations.reopenPullRequest,
      variables: {
        reopenPullRequestInput: {
          pullRequestId: pullRequest.id
        }
      },
      update: (store, _ref6) => {
        let {
          data: mutationResult
        } = _ref6;
        const {
          pullRequest
        } = mutationResult.reopenPullRequest;
        const pullRequestData = {
          repository: _objectSpread({}, pullRequest.repository, {
            pullRequest
          })
        };
        store.writeQuery(_objectSpread({}, this.getPullRequestQuery(pullRequest.number), {
          data: pullRequestData
        }));
      }
    });
    return data.closePullRequest;
  }

  async closePR(_ref7) {
    let {
      number
    } = _ref7;
    const pullRequest = await this.getPullRequest(number);
    const {
      data
    } = await this.mutate({
      mutation: mutations.closePullRequest,
      variables: {
        closePullRequestInput: {
          pullRequestId: pullRequest.id
        }
      },
      update: (store, _ref8) => {
        let {
          data: mutationResult
        } = _ref8;
        const {
          pullRequest
        } = mutationResult.closePullRequest;
        const pullRequestData = {
          repository: _objectSpread({}, pullRequest.repository, {
            pullRequest
          })
        };
        store.writeQuery(_objectSpread({}, this.getPullRequestQuery(pullRequest.number), {
          data: pullRequestData
        }));
      }
    });
    return data.closePullRequest;
  }

  async deleteUnpublishedEntry(collectionName, slug) {
    try {
      const contentKey = this.generateContentKey(collectionName, slug);
      const branchName = this.generateBranchName(contentKey);
      const metadata = await this.retrieveMetadata(contentKey);

      if (metadata && metadata.pr) {
        const {
          branch,
          pullRequest
        } = await this.getPullRequestAndBranch(branchName, metadata.pr.number);
        const {
          data
        } = await this.mutate({
          mutation: mutations.closePullRequestAndDeleteBranch,
          variables: {
            deleteRefInput: {
              refId: branch.id
            },
            closePullRequestInput: {
              pullRequestId: pullRequest.id
            }
          },
          update: store => {
            store.data.delete((0, _apolloCacheInmemory.defaultDataIdFromObject)(branch));
            store.data.delete((0, _apolloCacheInmemory.defaultDataIdFromObject)(pullRequest));
          }
        });
        return data.closePullRequest;
      } else {
        return await this.deleteBranch(branchName);
      }
    } catch (e) {
      const {
        graphQLErrors
      } = e;

      if (graphQLErrors && graphQLErrors.length > 0) {
        const branchNotFound = graphQLErrors.some(e => e.type === 'NOT_FOUND');

        if (branchNotFound) {
          return;
        }
      }

      throw e;
    }
  }

  async createPR(title, head) {
    const [repository, headReference] = await Promise.all([this.getRepository(this.origin_repo_owner, this.origin_repo_name), this.useOpenAuthoring ? "".concat((await this.user()).login, ":").concat(head) : head]);
    const {
      data
    } = await this.mutate({
      mutation: mutations.createPullRequest,
      variables: {
        createPullRequestInput: {
          baseRefName: this.branch,
          body: _API.default.DEFAULT_PR_BODY,
          title,
          headRefName: headReference,
          repositoryId: repository.id
        }
      },
      update: (store, _ref9) => {
        let {
          data: mutationResult
        } = _ref9;
        const {
          pullRequest
        } = mutationResult.createPullRequest;
        const pullRequestData = {
          repository: _objectSpread({}, pullRequest.repository, {
            pullRequest
          })
        };
        store.writeQuery(_objectSpread({}, this.getPullRequestQuery(pullRequest.number), {
          data: pullRequestData
        }));
      }
    });
    const {
      pullRequest
    } = data.createPullRequest;
    return _objectSpread({}, pullRequest, {
      head: {
        sha: pullRequest.headRefOid
      }
    });
  }

  async createBranch(branchName, sha) {
    const repository = await this.getRepository(this.repo_owner, this.repo_name);
    const {
      data
    } = await this.mutate({
      mutation: mutations.createBranch,
      variables: {
        createRefInput: {
          name: this.getBranchQualifiedName(branchName),
          oid: sha,
          repositoryId: repository.id
        }
      },
      update: (store, _ref10) => {
        let {
          data: mutationResult
        } = _ref10;
        const {
          branch
        } = mutationResult.createRef;
        const branchData = {
          repository: _objectSpread({}, branch.repository, {
            branch
          })
        };
        store.writeQuery(_objectSpread({}, this.getBranchQuery(branchName), {
          data: branchData
        }));
      }
    });
    const {
      branch
    } = data.createRef;
    return branch;
  }

  async createBranchAndPullRequest(branchName, sha, title) {
    const repository = await this.getRepository(this.origin_repo_owner, this.origin_repo_name);
    const {
      data
    } = await this.mutate({
      mutation: mutations.createBranchAndPullRequest,
      variables: {
        createRefInput: {
          name: this.getBranchQualifiedName(branchName),
          oid: sha,
          repositoryId: repository.id
        },
        createPullRequestInput: {
          baseRefName: this.branch,
          body: _API.default.DEFAULT_PR_BODY,
          title,
          headRefName: branchName,
          repositoryId: repository.id
        }
      },
      update: (store, _ref11) => {
        let {
          data: mutationResult
        } = _ref11;
        const {
          branch
        } = mutationResult.createRef;
        const {
          pullRequest
        } = mutationResult.createPullRequest;
        const branchData = {
          repository: _objectSpread({}, branch.repository, {
            branch
          })
        };
        const pullRequestData = {
          repository: _objectSpread({}, pullRequest.repository, {
            branch
          }),
          origin: _objectSpread({}, pullRequest.repository, {
            pullRequest
          })
        };
        store.writeQuery(_objectSpread({}, this.getBranchQuery(branchName), {
          data: branchData
        }));
        store.writeQuery(_objectSpread({}, this.getPullRequestAndBranchQuery(branchName, pullRequest.number), {
          data: pullRequestData
        }));
      }
    });
    const {
      pullRequest
    } = data.createPullRequest;
    return _objectSpread({}, pullRequest, {
      head: {
        sha: pullRequest.headRefOid
      }
    });
  }

  async getTree(sha) {
    if (!sha) {
      return Promise.resolve({
        tree: []
      });
    }

    const {
      repo_owner: owner,
      repo_name: name
    } = this;
    const variables = {
      owner,
      name,
      sha
    }; // sha can be either for a commit or a tree

    const [commitTree, tree] = await Promise.all([this.client.query({
      query: queries.commitTree,
      variables,
      fetchPolicy: CACHE_FIRST
    }), this.client.query({
      query: queries.tree,
      variables,
      fetchPolicy: CACHE_FIRST
    })]);
    let entries = null;

    if (commitTree.data.repository.commit.tree) {
      ({
        entries,
        sha
      } = commitTree.data.repository.commit.tree);
    }

    if (tree.data.repository.tree.entries) {
      ({
        entries,
        sha
      } = tree.data.repository.tree);
    }

    if (entries) {
      return {
        sha,
        tree: entries.map(e => _objectSpread({}, e, {
          mode: TREE_ENTRY_TYPE_TO_MODE[e.type]
        }))
      };
    }

    return Promise.reject('Could not get tree');
  }

  async getPullRequestCommits(number) {
    const {
      origin_repo_owner: owner,
      origin_repo_name: name
    } = this;
    const {
      data
    } = await this.query({
      query: queries.pullRequestCommits,
      variables: {
        owner,
        name,
        number
      }
    });
    const {
      nodes
    } = data.repository.pullRequest.commits;
    const commits = nodes.map(n => _objectSpread({}, n.commit, {
      parents: n.commit.parents.nodes
    }));
    return commits;
  }

  async getFileSha(path, branch) {
    const {
      repo_owner: owner,
      repo_name: name
    } = this;
    const {
      data
    } = await this.query({
      query: queries.fileSha,
      variables: {
        owner,
        name,
        expression: "".concat(branch, ":").concat(path)
      }
    });
    return data.repository.file.sha;
  }

}

exports.default = GraphQLAPI;