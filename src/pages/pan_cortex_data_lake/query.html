<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>pan_cortex_data_lake.query API documentation</title>
<meta name="description" content="Interact with the Cortex Query Service API …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pan_cortex_data_lake.query</code></h1>
</header>
<section id="section-intro">
<p>Interact with the Cortex Query Service API.</p>
<p>The Query Service is a Palo Alto Networks cloud service which allows
for the storage and retrieval of data stored in the Cortex Data Lake.
Any type of textual data can be stored in the Cortex Data Lake. Palo
Alto Networks firewalls and software can write data to this service, as
can the software and services created by Palo Alto Network's various
partners.</p>
<h2 id="examples">Examples</h2>
<p>Refer to the examples provided with this library.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-

&#34;&#34;&#34;Interact with the Cortex Query Service API.

The Query Service is a Palo Alto Networks cloud service which allows
for the storage and retrieval of data stored in the Cortex Data Lake.
Any type of textual data can be stored in the Cortex Data Lake. Palo
Alto Networks firewalls and software can write data to this service, as
can the software and services created by Palo Alto Network&#39;s various
partners.

Examples:
    Refer to the examples provided with this library.

&#34;&#34;&#34;

from __future__ import absolute_import
import logging
import time

from .exceptions import CortexError, HTTPError
from .httpclient import HTTPClient
from . import __version__


class QueryService(object):
    &#34;&#34;&#34;A Cortex™ Query Service instance.&#34;&#34;&#34;

    def __init__(self, **kwargs):
        &#34;&#34;&#34;

        Parameters:
            session (HTTPClient): :class:`~cortex.httpclient.HTTPClient` object. Defaults to ``None``.
            url (str): URL to send API requests to. Later combined with ``port`` and :meth:`~request` ``endpoint`` parameter.

        Args:
            **kwargs: Supported :class:`~cortex.httpclient.HTTPClient` parameters.

        &#34;&#34;&#34;
        self.kwargs = kwargs.copy()  # used for __repr__
        self.session = kwargs.pop(&#34;session&#34;, None)
        self._httpclient = self.session or HTTPClient(**kwargs)
        self._httpclient.stats.update(
            {
                &#34;cancel_job&#34;: 0,
                &#34;create_query&#34;: 0,
                &#34;get_job&#34;: 0,
                &#34;list_jobs&#34;: 0,
                &#34;get_job_results&#34;: 0,
                &#34;records&#34;: 0,
            }
        )
        self.stats = self._httpclient.stats
        self.url = self._httpclient.url
        self._debug = logging.getLogger(__name__).debug

    def __repr__(self):
        for k in self.kwargs.get(&#34;headers&#34;, {}):
            if k.lower() == &#34;authorization&#34;:
                x = dict(self.kwargs[&#34;headers&#34;].items())
                x[k] = &#34;*&#34; * 6  # starrify token
                return &#34;{}({}, {})&#34;.format(
                    self.__class__.__name__,
                    &#34;, &#34;.join(
                        &#34;%s=%r&#34; % (x, _)
                        for x, _ in self.kwargs.items()
                        if x != &#34;headers&#34;
                    ),
                    &#34;headers=%r&#34; % x,
                )
        return &#34;{}({})&#34;.format(
            self.__class__.__name__, &#34;, &#34;.join(&#34;%s=%r&#34; % x for x in self.kwargs.items())
        )

    def cancel_job(self, job_id=None, **kwargs):
        &#34;&#34;&#34;Cancel a query job.

        Args:
            job_id (str): Specifies the ID of the query job.
            **kwargs: Supported :meth:`~pan_cortex_data_lake.httpclient.HTTPClient.request` parameters.

        Returns:
            requests.Response: Requests Response() object.

        &#34;&#34;&#34;
        endpoint = &#34;/query/v2/jobs/{}&#34;.format(job_id)
        r = self._httpclient.request(
            method=&#34;DELETE&#34;, url=self.url, endpoint=endpoint, **kwargs
        )
        self.stats.cancel_job += 1
        return r

    def create_query(self, job_id=None, query_params=None, **kwargs):
        &#34;&#34;&#34;Create a search request.

        When submission is successful, http status code of 201 (Created)
        is returned with a &#39;jobId&#39; in response. Specifying a &#39;jobId&#39; is
        optional.

        Args:
            job_id (str): Specifies the ID of the query job. (optional)
            query_params (dict): Query parameters.
            **kwargs: Supported :meth:`~pan_cortex_data_lake.httpclient.HTTPClient.request` parameters.

        Returns:
            requests.Response: Requests Response() object.

        &#34;&#34;&#34;
        json = kwargs.pop(&#34;json&#34;, {})
        for name, value in [(&#34;jobId&#34;, job_id), (&#34;params&#34;, query_params)]:
            if value is not None:
                json.update({name: value})
        json.update(
            {
                &#34;clientType&#34;: &#34;cortex-data-lake-python&#34;,
                &#34;clientVersion&#34;: &#34;%s&#34; % __version__,
            }
        )
        endpoint = &#34;/query/v2/jobs&#34;
        r = self._httpclient.request(
            method=&#34;POST&#34;, url=self.url, json=json, endpoint=endpoint, **kwargs
        )
        self.stats.create_query += 1
        return r

    def get_job(self, job_id=None, **kwargs):
        &#34;&#34;&#34;Get specific job matching criteria.

        Args:
            job_id (str): Specifies the ID of the query job.
            params (dict): Payload/request dictionary.
            **kwargs: Supported :meth:`~pan_cortex_data_lake.httpclient.HTTPClient.request` parameters.

        Returns:
            requests.Response: Requests Response() object.

        &#34;&#34;&#34;
        endpoint = &#34;/query/v2/jobs/{}&#34;.format(job_id)
        r = self._httpclient.request(
            method=&#34;GET&#34;, url=self.url, endpoint=endpoint, **kwargs
        )
        self.stats.get_job += 1
        return r

    def get_job_results(
        self,
        job_id=None,
        max_wait=None,
        offset=None,
        page_cursor=None,
        page_number=None,
        page_size=None,
        result_format=None,
        **kwargs
    ):
        &#34;&#34;&#34;Get results for a specific job_id.

        Args:
            job_id (str): Specifies the ID of the query job.
            max_wait (int): How long to wait in ms for a job to complete. Max 2000.
            offset (int): Along with pageSize, offset can be used to page through result set.
            page_cursor (str): Token/handle that can be used to fetch more data.
            page_number (int): Return the nth page from the result set as specified by this parameter.
            page_size (int): If specified, limits the size of a batch of results to the specified value. If un-specified, backend picks a size that may provide best performance.
            result_format (str): valuesArray or valuesJson.
            **kwargs: Supported :meth:`~pan_cortex_data_lake.httpclient.HTTPClient.request` parameters.

        Returns:
            requests.Response: Requests Response() object.

        &#34;&#34;&#34;
        params = kwargs.pop(&#34;params&#34;, {})
        for name, value in [
            (&#34;maxWait&#34;, max_wait),
            (&#34;offset&#34;, offset),
            (&#34;pageCursor&#34;, page_cursor),
            (&#34;pageNumber&#34;, page_number),
            (&#34;pageSize&#34;, page_size),
            (&#34;resultFormat&#34;, result_format),
        ]:
            if value is not None:
                params.update({name: value})
        endpoint = &#34;/query/v2/jobResults/{}&#34;.format(job_id)
        r = self._httpclient.request(
            method=&#34;GET&#34;, url=self.url, params=params, endpoint=endpoint, **kwargs
        )
        self.stats.get_job_results += 1

        rows = r.json().get(&#34;rowsInPage&#34;)
        if rows is not None:
            self.stats.records += rows

        return r

    def iter_job_results(
        self,
        job_id=None,
        max_wait=None,
        offset=None,
        page_cursor=None,
        page_number=None,
        page_size=None,
        result_format=None,
        **kwargs
    ):
        &#34;&#34;&#34;Retrieve results iteratively in a non-greedy manner using scroll token.

        Args:
            job_id (str): Specifies the ID of the query job.
            max_wait (int): How long to wait in ms for a job to complete. Max 2000.
            offset (int): Along with pageSize, offset can be used to page through result set.
            page_cursor (str): Token/handle that can be used to fetch more data.
            page_number (int): Return the nth page from the result set as specified by this parameter.
            page_size (int): If specified, limits the size of a batch of results to the specified value. If un-specified, backend picks a size that may provide best performance.
            result_format (str): valuesArray or valuesJson.
            **kwargs: Supported :meth:`~pan_cortex_data_lake.httpclient.HTTPClient.request` parameters.

        Yields:
            requests.Response: Requests Response() object.

        &#34;&#34;&#34;
        params = kwargs.pop(&#34;params&#34;, {})
        enforce_json = kwargs.pop(&#34;enforce_json&#34;, True)
        for name, value in [
            (&#34;maxWait&#34;, max_wait),
            (&#34;offset&#34;, offset),
            (&#34;pageCursor&#34;, page_cursor),
            (&#34;pageNumber&#34;, page_number),
            (&#34;pageSize&#34;, page_size),
            (&#34;resultFormat&#34;, result_format),
        ]:
            if value is not None:
                params.update({name: value})

        while True:
            r = self.get_job_results(
                job_id=job_id, params=params, enforce_json=enforce_json, **kwargs
            )
            r_json = r.json()
            if r_json[&#34;state&#34;] == &#34;DONE&#34;:
                page_cursor = r_json[&#34;page&#34;].get(&#34;pageCursor&#34;)
                if page_cursor is not None:
                    params[&#34;pageCursor&#34;] = page_cursor
                    yield r
                else:
                    yield r
                    break
            elif r_json[&#34;state&#34;] in (&#34;RUNNING&#34;, &#34;PENDING&#34;):
                yield r
                time.sleep(1)
            elif r_json[&#34;state&#34;] == &#34;FAILED&#34;:
                yield r
                break
            else:
                raise CortexError(&#34;Bad state: %s&#34; % r_json[&#34;state&#34;])

    def list_jobs(
        self,
        max_jobs=None,
        created_after=None,
        state=None,
        job_type=None,
        tenant_id=None,
        **kwargs
    ):
        &#34;&#34;&#34;Get all jobs matching criteria.

        Args:
            limit (int): Max number of jobs.
            created_after (int): List jobs created after this unix epoch UTC datetime.
            state (str): Job state, e.g. &#39;RUNNING&#39;, &#39;PENDING&#39;, &#39;FAILED&#39;, &#39;DONE&#39;.
            job_type (str): Query type hint.
            tenant_id (str): Tenant ID.
            **kwargs: Supported :meth:`~pan_cortex_data_lake.httpclient.HTTPClient.request` parameters.

        Returns:
            requests.Response: Requests Response() object.

        &#34;&#34;&#34;
        params = kwargs.pop(&#34;params&#34;, {})
        for name, value in [
            (&#34;maxJobs&#34;, max_jobs),
            (&#34;createdAfter&#34;, created_after),
            (&#34;state&#34;, state),
            (&#34;type&#34;, job_type),
            (&#34;tenantId&#34;, tenant_id),
        ]:
            if value is not None:
                params.update({name: value})
        endpoint = &#34;/query/v2/jobs&#34;
        r = self._httpclient.request(
            method=&#34;GET&#34;, url=self.url, params=params, endpoint=endpoint, **kwargs
        )
        self.stats.list_jobs += 1
        return r</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pan_cortex_data_lake.query.QueryService"><code class="flex name class">
<span>class <span class="ident">QueryService</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A Cortex™ Query Service instance.</p>
<h2 id="parameters">Parameters</h2>
<p>session (HTTPClient): :class:<code>~cortex.httpclient.HTTPClient</code> object. Defaults to <code>None</code>.
url (str): URL to send API requests to. Later combined with <code>port</code> and :meth:<code>~request</code> <code>endpoint</code> parameter.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Supported :class:<code>~cortex.httpclient.HTTPClient</code> parameters.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QueryService(object):
    &#34;&#34;&#34;A Cortex™ Query Service instance.&#34;&#34;&#34;

    def __init__(self, **kwargs):
        &#34;&#34;&#34;

        Parameters:
            session (HTTPClient): :class:`~cortex.httpclient.HTTPClient` object. Defaults to ``None``.
            url (str): URL to send API requests to. Later combined with ``port`` and :meth:`~request` ``endpoint`` parameter.

        Args:
            **kwargs: Supported :class:`~cortex.httpclient.HTTPClient` parameters.

        &#34;&#34;&#34;
        self.kwargs = kwargs.copy()  # used for __repr__
        self.session = kwargs.pop(&#34;session&#34;, None)
        self._httpclient = self.session or HTTPClient(**kwargs)
        self._httpclient.stats.update(
            {
                &#34;cancel_job&#34;: 0,
                &#34;create_query&#34;: 0,
                &#34;get_job&#34;: 0,
                &#34;list_jobs&#34;: 0,
                &#34;get_job_results&#34;: 0,
                &#34;records&#34;: 0,
            }
        )
        self.stats = self._httpclient.stats
        self.url = self._httpclient.url
        self._debug = logging.getLogger(__name__).debug

    def __repr__(self):
        for k in self.kwargs.get(&#34;headers&#34;, {}):
            if k.lower() == &#34;authorization&#34;:
                x = dict(self.kwargs[&#34;headers&#34;].items())
                x[k] = &#34;*&#34; * 6  # starrify token
                return &#34;{}({}, {})&#34;.format(
                    self.__class__.__name__,
                    &#34;, &#34;.join(
                        &#34;%s=%r&#34; % (x, _)
                        for x, _ in self.kwargs.items()
                        if x != &#34;headers&#34;
                    ),
                    &#34;headers=%r&#34; % x,
                )
        return &#34;{}({})&#34;.format(
            self.__class__.__name__, &#34;, &#34;.join(&#34;%s=%r&#34; % x for x in self.kwargs.items())
        )

    def cancel_job(self, job_id=None, **kwargs):
        &#34;&#34;&#34;Cancel a query job.

        Args:
            job_id (str): Specifies the ID of the query job.
            **kwargs: Supported :meth:`~pan_cortex_data_lake.httpclient.HTTPClient.request` parameters.

        Returns:
            requests.Response: Requests Response() object.

        &#34;&#34;&#34;
        endpoint = &#34;/query/v2/jobs/{}&#34;.format(job_id)
        r = self._httpclient.request(
            method=&#34;DELETE&#34;, url=self.url, endpoint=endpoint, **kwargs
        )
        self.stats.cancel_job += 1
        return r

    def create_query(self, job_id=None, query_params=None, **kwargs):
        &#34;&#34;&#34;Create a search request.

        When submission is successful, http status code of 201 (Created)
        is returned with a &#39;jobId&#39; in response. Specifying a &#39;jobId&#39; is
        optional.

        Args:
            job_id (str): Specifies the ID of the query job. (optional)
            query_params (dict): Query parameters.
            **kwargs: Supported :meth:`~pan_cortex_data_lake.httpclient.HTTPClient.request` parameters.

        Returns:
            requests.Response: Requests Response() object.

        &#34;&#34;&#34;
        json = kwargs.pop(&#34;json&#34;, {})
        for name, value in [(&#34;jobId&#34;, job_id), (&#34;params&#34;, query_params)]:
            if value is not None:
                json.update({name: value})
        json.update(
            {
                &#34;clientType&#34;: &#34;cortex-data-lake-python&#34;,
                &#34;clientVersion&#34;: &#34;%s&#34; % __version__,
            }
        )
        endpoint = &#34;/query/v2/jobs&#34;
        r = self._httpclient.request(
            method=&#34;POST&#34;, url=self.url, json=json, endpoint=endpoint, **kwargs
        )
        self.stats.create_query += 1
        return r

    def get_job(self, job_id=None, **kwargs):
        &#34;&#34;&#34;Get specific job matching criteria.

        Args:
            job_id (str): Specifies the ID of the query job.
            params (dict): Payload/request dictionary.
            **kwargs: Supported :meth:`~pan_cortex_data_lake.httpclient.HTTPClient.request` parameters.

        Returns:
            requests.Response: Requests Response() object.

        &#34;&#34;&#34;
        endpoint = &#34;/query/v2/jobs/{}&#34;.format(job_id)
        r = self._httpclient.request(
            method=&#34;GET&#34;, url=self.url, endpoint=endpoint, **kwargs
        )
        self.stats.get_job += 1
        return r

    def get_job_results(
        self,
        job_id=None,
        max_wait=None,
        offset=None,
        page_cursor=None,
        page_number=None,
        page_size=None,
        result_format=None,
        **kwargs
    ):
        &#34;&#34;&#34;Get results for a specific job_id.

        Args:
            job_id (str): Specifies the ID of the query job.
            max_wait (int): How long to wait in ms for a job to complete. Max 2000.
            offset (int): Along with pageSize, offset can be used to page through result set.
            page_cursor (str): Token/handle that can be used to fetch more data.
            page_number (int): Return the nth page from the result set as specified by this parameter.
            page_size (int): If specified, limits the size of a batch of results to the specified value. If un-specified, backend picks a size that may provide best performance.
            result_format (str): valuesArray or valuesJson.
            **kwargs: Supported :meth:`~pan_cortex_data_lake.httpclient.HTTPClient.request` parameters.

        Returns:
            requests.Response: Requests Response() object.

        &#34;&#34;&#34;
        params = kwargs.pop(&#34;params&#34;, {})
        for name, value in [
            (&#34;maxWait&#34;, max_wait),
            (&#34;offset&#34;, offset),
            (&#34;pageCursor&#34;, page_cursor),
            (&#34;pageNumber&#34;, page_number),
            (&#34;pageSize&#34;, page_size),
            (&#34;resultFormat&#34;, result_format),
        ]:
            if value is not None:
                params.update({name: value})
        endpoint = &#34;/query/v2/jobResults/{}&#34;.format(job_id)
        r = self._httpclient.request(
            method=&#34;GET&#34;, url=self.url, params=params, endpoint=endpoint, **kwargs
        )
        self.stats.get_job_results += 1

        rows = r.json().get(&#34;rowsInPage&#34;)
        if rows is not None:
            self.stats.records += rows

        return r

    def iter_job_results(
        self,
        job_id=None,
        max_wait=None,
        offset=None,
        page_cursor=None,
        page_number=None,
        page_size=None,
        result_format=None,
        **kwargs
    ):
        &#34;&#34;&#34;Retrieve results iteratively in a non-greedy manner using scroll token.

        Args:
            job_id (str): Specifies the ID of the query job.
            max_wait (int): How long to wait in ms for a job to complete. Max 2000.
            offset (int): Along with pageSize, offset can be used to page through result set.
            page_cursor (str): Token/handle that can be used to fetch more data.
            page_number (int): Return the nth page from the result set as specified by this parameter.
            page_size (int): If specified, limits the size of a batch of results to the specified value. If un-specified, backend picks a size that may provide best performance.
            result_format (str): valuesArray or valuesJson.
            **kwargs: Supported :meth:`~pan_cortex_data_lake.httpclient.HTTPClient.request` parameters.

        Yields:
            requests.Response: Requests Response() object.

        &#34;&#34;&#34;
        params = kwargs.pop(&#34;params&#34;, {})
        enforce_json = kwargs.pop(&#34;enforce_json&#34;, True)
        for name, value in [
            (&#34;maxWait&#34;, max_wait),
            (&#34;offset&#34;, offset),
            (&#34;pageCursor&#34;, page_cursor),
            (&#34;pageNumber&#34;, page_number),
            (&#34;pageSize&#34;, page_size),
            (&#34;resultFormat&#34;, result_format),
        ]:
            if value is not None:
                params.update({name: value})

        while True:
            r = self.get_job_results(
                job_id=job_id, params=params, enforce_json=enforce_json, **kwargs
            )
            r_json = r.json()
            if r_json[&#34;state&#34;] == &#34;DONE&#34;:
                page_cursor = r_json[&#34;page&#34;].get(&#34;pageCursor&#34;)
                if page_cursor is not None:
                    params[&#34;pageCursor&#34;] = page_cursor
                    yield r
                else:
                    yield r
                    break
            elif r_json[&#34;state&#34;] in (&#34;RUNNING&#34;, &#34;PENDING&#34;):
                yield r
                time.sleep(1)
            elif r_json[&#34;state&#34;] == &#34;FAILED&#34;:
                yield r
                break
            else:
                raise CortexError(&#34;Bad state: %s&#34; % r_json[&#34;state&#34;])

    def list_jobs(
        self,
        max_jobs=None,
        created_after=None,
        state=None,
        job_type=None,
        tenant_id=None,
        **kwargs
    ):
        &#34;&#34;&#34;Get all jobs matching criteria.

        Args:
            limit (int): Max number of jobs.
            created_after (int): List jobs created after this unix epoch UTC datetime.
            state (str): Job state, e.g. &#39;RUNNING&#39;, &#39;PENDING&#39;, &#39;FAILED&#39;, &#39;DONE&#39;.
            job_type (str): Query type hint.
            tenant_id (str): Tenant ID.
            **kwargs: Supported :meth:`~pan_cortex_data_lake.httpclient.HTTPClient.request` parameters.

        Returns:
            requests.Response: Requests Response() object.

        &#34;&#34;&#34;
        params = kwargs.pop(&#34;params&#34;, {})
        for name, value in [
            (&#34;maxJobs&#34;, max_jobs),
            (&#34;createdAfter&#34;, created_after),
            (&#34;state&#34;, state),
            (&#34;type&#34;, job_type),
            (&#34;tenantId&#34;, tenant_id),
        ]:
            if value is not None:
                params.update({name: value})
        endpoint = &#34;/query/v2/jobs&#34;
        r = self._httpclient.request(
            method=&#34;GET&#34;, url=self.url, params=params, endpoint=endpoint, **kwargs
        )
        self.stats.list_jobs += 1
        return r</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pan_cortex_data_lake.query.QueryService.cancel_job"><code class="name flex">
<span>def <span class="ident">cancel_job</span></span>(<span>self, job_id=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Cancel a query job.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>job_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Specifies the ID of the query job.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Supported :meth:<code>~pan_cortex_data_lake.httpclient.HTTPClient.request</code> parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>requests.Response</code></dt>
<dd>Requests Response() object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel_job(self, job_id=None, **kwargs):
    &#34;&#34;&#34;Cancel a query job.

    Args:
        job_id (str): Specifies the ID of the query job.
        **kwargs: Supported :meth:`~pan_cortex_data_lake.httpclient.HTTPClient.request` parameters.

    Returns:
        requests.Response: Requests Response() object.

    &#34;&#34;&#34;
    endpoint = &#34;/query/v2/jobs/{}&#34;.format(job_id)
    r = self._httpclient.request(
        method=&#34;DELETE&#34;, url=self.url, endpoint=endpoint, **kwargs
    )
    self.stats.cancel_job += 1
    return r</code></pre>
</details>
</dd>
<dt id="pan_cortex_data_lake.query.QueryService.create_query"><code class="name flex">
<span>def <span class="ident">create_query</span></span>(<span>self, job_id=None, query_params=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a search request.</p>
<p>When submission is successful, http status code of 201 (Created)
is returned with a 'jobId' in response. Specifying a 'jobId' is
optional.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>job_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Specifies the ID of the query job. (optional)</dd>
<dt><strong><code>query_params</code></strong> :&ensp;<code>dict</code></dt>
<dd>Query parameters.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Supported :meth:<code>~pan_cortex_data_lake.httpclient.HTTPClient.request</code> parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>requests.Response</code></dt>
<dd>Requests Response() object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_query(self, job_id=None, query_params=None, **kwargs):
    &#34;&#34;&#34;Create a search request.

    When submission is successful, http status code of 201 (Created)
    is returned with a &#39;jobId&#39; in response. Specifying a &#39;jobId&#39; is
    optional.

    Args:
        job_id (str): Specifies the ID of the query job. (optional)
        query_params (dict): Query parameters.
        **kwargs: Supported :meth:`~pan_cortex_data_lake.httpclient.HTTPClient.request` parameters.

    Returns:
        requests.Response: Requests Response() object.

    &#34;&#34;&#34;
    json = kwargs.pop(&#34;json&#34;, {})
    for name, value in [(&#34;jobId&#34;, job_id), (&#34;params&#34;, query_params)]:
        if value is not None:
            json.update({name: value})
    json.update(
        {
            &#34;clientType&#34;: &#34;cortex-data-lake-python&#34;,
            &#34;clientVersion&#34;: &#34;%s&#34; % __version__,
        }
    )
    endpoint = &#34;/query/v2/jobs&#34;
    r = self._httpclient.request(
        method=&#34;POST&#34;, url=self.url, json=json, endpoint=endpoint, **kwargs
    )
    self.stats.create_query += 1
    return r</code></pre>
</details>
</dd>
<dt id="pan_cortex_data_lake.query.QueryService.get_job"><code class="name flex">
<span>def <span class="ident">get_job</span></span>(<span>self, job_id=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get specific job matching criteria.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>job_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Specifies the ID of the query job.</dd>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>Payload/request dictionary.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Supported :meth:<code>~pan_cortex_data_lake.httpclient.HTTPClient.request</code> parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>requests.Response</code></dt>
<dd>Requests Response() object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_job(self, job_id=None, **kwargs):
    &#34;&#34;&#34;Get specific job matching criteria.

    Args:
        job_id (str): Specifies the ID of the query job.
        params (dict): Payload/request dictionary.
        **kwargs: Supported :meth:`~pan_cortex_data_lake.httpclient.HTTPClient.request` parameters.

    Returns:
        requests.Response: Requests Response() object.

    &#34;&#34;&#34;
    endpoint = &#34;/query/v2/jobs/{}&#34;.format(job_id)
    r = self._httpclient.request(
        method=&#34;GET&#34;, url=self.url, endpoint=endpoint, **kwargs
    )
    self.stats.get_job += 1
    return r</code></pre>
</details>
</dd>
<dt id="pan_cortex_data_lake.query.QueryService.get_job_results"><code class="name flex">
<span>def <span class="ident">get_job_results</span></span>(<span>self, job_id=None, max_wait=None, offset=None, page_cursor=None, page_number=None, page_size=None, result_format=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get results for a specific job_id.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>job_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Specifies the ID of the query job.</dd>
<dt><strong><code>max_wait</code></strong> :&ensp;<code>int</code></dt>
<dd>How long to wait in ms for a job to complete. Max 2000.</dd>
<dt><strong><code>offset</code></strong> :&ensp;<code>int</code></dt>
<dd>Along with pageSize, offset can be used to page through result set.</dd>
<dt><strong><code>page_cursor</code></strong> :&ensp;<code>str</code></dt>
<dd>Token/handle that can be used to fetch more data.</dd>
<dt><strong><code>page_number</code></strong> :&ensp;<code>int</code></dt>
<dd>Return the nth page from the result set as specified by this parameter.</dd>
<dt><strong><code>page_size</code></strong> :&ensp;<code>int</code></dt>
<dd>If specified, limits the size of a batch of results to the specified value. If un-specified, backend picks a size that may provide best performance.</dd>
<dt><strong><code>result_format</code></strong> :&ensp;<code>str</code></dt>
<dd>valuesArray or valuesJson.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Supported :meth:<code>~pan_cortex_data_lake.httpclient.HTTPClient.request</code> parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>requests.Response</code></dt>
<dd>Requests Response() object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_job_results(
    self,
    job_id=None,
    max_wait=None,
    offset=None,
    page_cursor=None,
    page_number=None,
    page_size=None,
    result_format=None,
    **kwargs
):
    &#34;&#34;&#34;Get results for a specific job_id.

    Args:
        job_id (str): Specifies the ID of the query job.
        max_wait (int): How long to wait in ms for a job to complete. Max 2000.
        offset (int): Along with pageSize, offset can be used to page through result set.
        page_cursor (str): Token/handle that can be used to fetch more data.
        page_number (int): Return the nth page from the result set as specified by this parameter.
        page_size (int): If specified, limits the size of a batch of results to the specified value. If un-specified, backend picks a size that may provide best performance.
        result_format (str): valuesArray or valuesJson.
        **kwargs: Supported :meth:`~pan_cortex_data_lake.httpclient.HTTPClient.request` parameters.

    Returns:
        requests.Response: Requests Response() object.

    &#34;&#34;&#34;
    params = kwargs.pop(&#34;params&#34;, {})
    for name, value in [
        (&#34;maxWait&#34;, max_wait),
        (&#34;offset&#34;, offset),
        (&#34;pageCursor&#34;, page_cursor),
        (&#34;pageNumber&#34;, page_number),
        (&#34;pageSize&#34;, page_size),
        (&#34;resultFormat&#34;, result_format),
    ]:
        if value is not None:
            params.update({name: value})
    endpoint = &#34;/query/v2/jobResults/{}&#34;.format(job_id)
    r = self._httpclient.request(
        method=&#34;GET&#34;, url=self.url, params=params, endpoint=endpoint, **kwargs
    )
    self.stats.get_job_results += 1

    rows = r.json().get(&#34;rowsInPage&#34;)
    if rows is not None:
        self.stats.records += rows

    return r</code></pre>
</details>
</dd>
<dt id="pan_cortex_data_lake.query.QueryService.iter_job_results"><code class="name flex">
<span>def <span class="ident">iter_job_results</span></span>(<span>self, job_id=None, max_wait=None, offset=None, page_cursor=None, page_number=None, page_size=None, result_format=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve results iteratively in a non-greedy manner using scroll token.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>job_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Specifies the ID of the query job.</dd>
<dt><strong><code>max_wait</code></strong> :&ensp;<code>int</code></dt>
<dd>How long to wait in ms for a job to complete. Max 2000.</dd>
<dt><strong><code>offset</code></strong> :&ensp;<code>int</code></dt>
<dd>Along with pageSize, offset can be used to page through result set.</dd>
<dt><strong><code>page_cursor</code></strong> :&ensp;<code>str</code></dt>
<dd>Token/handle that can be used to fetch more data.</dd>
<dt><strong><code>page_number</code></strong> :&ensp;<code>int</code></dt>
<dd>Return the nth page from the result set as specified by this parameter.</dd>
<dt><strong><code>page_size</code></strong> :&ensp;<code>int</code></dt>
<dd>If specified, limits the size of a batch of results to the specified value. If un-specified, backend picks a size that may provide best performance.</dd>
<dt><strong><code>result_format</code></strong> :&ensp;<code>str</code></dt>
<dd>valuesArray or valuesJson.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Supported :meth:<code>~pan_cortex_data_lake.httpclient.HTTPClient.request</code> parameters.</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>requests.Response</code></dt>
<dd>Requests Response() object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iter_job_results(
    self,
    job_id=None,
    max_wait=None,
    offset=None,
    page_cursor=None,
    page_number=None,
    page_size=None,
    result_format=None,
    **kwargs
):
    &#34;&#34;&#34;Retrieve results iteratively in a non-greedy manner using scroll token.

    Args:
        job_id (str): Specifies the ID of the query job.
        max_wait (int): How long to wait in ms for a job to complete. Max 2000.
        offset (int): Along with pageSize, offset can be used to page through result set.
        page_cursor (str): Token/handle that can be used to fetch more data.
        page_number (int): Return the nth page from the result set as specified by this parameter.
        page_size (int): If specified, limits the size of a batch of results to the specified value. If un-specified, backend picks a size that may provide best performance.
        result_format (str): valuesArray or valuesJson.
        **kwargs: Supported :meth:`~pan_cortex_data_lake.httpclient.HTTPClient.request` parameters.

    Yields:
        requests.Response: Requests Response() object.

    &#34;&#34;&#34;
    params = kwargs.pop(&#34;params&#34;, {})
    enforce_json = kwargs.pop(&#34;enforce_json&#34;, True)
    for name, value in [
        (&#34;maxWait&#34;, max_wait),
        (&#34;offset&#34;, offset),
        (&#34;pageCursor&#34;, page_cursor),
        (&#34;pageNumber&#34;, page_number),
        (&#34;pageSize&#34;, page_size),
        (&#34;resultFormat&#34;, result_format),
    ]:
        if value is not None:
            params.update({name: value})

    while True:
        r = self.get_job_results(
            job_id=job_id, params=params, enforce_json=enforce_json, **kwargs
        )
        r_json = r.json()
        if r_json[&#34;state&#34;] == &#34;DONE&#34;:
            page_cursor = r_json[&#34;page&#34;].get(&#34;pageCursor&#34;)
            if page_cursor is not None:
                params[&#34;pageCursor&#34;] = page_cursor
                yield r
            else:
                yield r
                break
        elif r_json[&#34;state&#34;] in (&#34;RUNNING&#34;, &#34;PENDING&#34;):
            yield r
            time.sleep(1)
        elif r_json[&#34;state&#34;] == &#34;FAILED&#34;:
            yield r
            break
        else:
            raise CortexError(&#34;Bad state: %s&#34; % r_json[&#34;state&#34;])</code></pre>
</details>
</dd>
<dt id="pan_cortex_data_lake.query.QueryService.list_jobs"><code class="name flex">
<span>def <span class="ident">list_jobs</span></span>(<span>self, max_jobs=None, created_after=None, state=None, job_type=None, tenant_id=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all jobs matching criteria.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>limit</code></strong> :&ensp;<code>int</code></dt>
<dd>Max number of jobs.</dd>
<dt><strong><code>created_after</code></strong> :&ensp;<code>int</code></dt>
<dd>List jobs created after this unix epoch UTC datetime.</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>str</code></dt>
<dd>Job state, e.g. 'RUNNING', 'PENDING', 'FAILED', 'DONE'.</dd>
<dt><strong><code>job_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Query type hint.</dd>
<dt><strong><code>tenant_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Tenant ID.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Supported :meth:<code>~pan_cortex_data_lake.httpclient.HTTPClient.request</code> parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>requests.Response</code></dt>
<dd>Requests Response() object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_jobs(
    self,
    max_jobs=None,
    created_after=None,
    state=None,
    job_type=None,
    tenant_id=None,
    **kwargs
):
    &#34;&#34;&#34;Get all jobs matching criteria.

    Args:
        limit (int): Max number of jobs.
        created_after (int): List jobs created after this unix epoch UTC datetime.
        state (str): Job state, e.g. &#39;RUNNING&#39;, &#39;PENDING&#39;, &#39;FAILED&#39;, &#39;DONE&#39;.
        job_type (str): Query type hint.
        tenant_id (str): Tenant ID.
        **kwargs: Supported :meth:`~pan_cortex_data_lake.httpclient.HTTPClient.request` parameters.

    Returns:
        requests.Response: Requests Response() object.

    &#34;&#34;&#34;
    params = kwargs.pop(&#34;params&#34;, {})
    for name, value in [
        (&#34;maxJobs&#34;, max_jobs),
        (&#34;createdAfter&#34;, created_after),
        (&#34;state&#34;, state),
        (&#34;type&#34;, job_type),
        (&#34;tenantId&#34;, tenant_id),
    ]:
        if value is not None:
            params.update({name: value})
    endpoint = &#34;/query/v2/jobs&#34;
    r = self._httpclient.request(
        method=&#34;GET&#34;, url=self.url, params=params, endpoint=endpoint, **kwargs
    )
    self.stats.list_jobs += 1
    return r</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pan_cortex_data_lake" href="index.html">pan_cortex_data_lake</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pan_cortex_data_lake.query.QueryService" href="#pan_cortex_data_lake.query.QueryService">QueryService</a></code></h4>
<ul class="two-column">
<li><code><a title="pan_cortex_data_lake.query.QueryService.cancel_job" href="#pan_cortex_data_lake.query.QueryService.cancel_job">cancel_job</a></code></li>
<li><code><a title="pan_cortex_data_lake.query.QueryService.create_query" href="#pan_cortex_data_lake.query.QueryService.create_query">create_query</a></code></li>
<li><code><a title="pan_cortex_data_lake.query.QueryService.get_job" href="#pan_cortex_data_lake.query.QueryService.get_job">get_job</a></code></li>
<li><code><a title="pan_cortex_data_lake.query.QueryService.get_job_results" href="#pan_cortex_data_lake.query.QueryService.get_job_results">get_job_results</a></code></li>
<li><code><a title="pan_cortex_data_lake.query.QueryService.iter_job_results" href="#pan_cortex_data_lake.query.QueryService.iter_job_results">iter_job_results</a></code></li>
<li><code><a title="pan_cortex_data_lake.query.QueryService.list_jobs" href="#pan_cortex_data_lake.query.QueryService.list_jobs">list_jobs</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>