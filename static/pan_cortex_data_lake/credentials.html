<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>pan_cortex_data_lake.credentials API documentation</title>
<meta name="description" content="Access, store and refresh credentials." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pan_cortex_data_lake.credentials</code></h1>
</header>
<section id="section-intro">
<p>Access, store and refresh credentials.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-

&#34;&#34;&#34;Access, store and refresh credentials.&#34;&#34;&#34;
from __future__ import absolute_import

import os
import sys
import uuid
from collections import namedtuple
from threading import Lock

try:
    from urllib.parse import urlparse
except ImportError:
    from urlparse import urlparse

from requests import Request
from time import time
from base64 import b64decode
from json import loads

from .httpclient import HTTPClient
from .exceptions import CortexError, PartialCredentialsError

# Constants
API_BASE_URL = &#34;https://api.paloaltonetworks.com&#34;
AUTH_BASE_URL = &#34;https://identity.paloaltonetworks.com/as/authorization.oauth2&#34;
DEVELOPER_TOKEN_PROVIDER = &#34;https://app.apiexplorer.rocks/request_token&#34;

ReadOnlyCredentials = namedtuple(
    &#34;ReadOnlyCredentials&#34;,
    [&#34;access_token&#34;, &#34;client_id&#34;, &#34;client_secret&#34;, &#34;refresh_token&#34;],
)


class Credentials(object):
    &#34;&#34;&#34;An Application Framework credentials object.&#34;&#34;&#34;

    def __init__(
        self,
        access_token=None,
        auth_base_url=None,
        cache_token=True,
        client_id=None,
        client_secret=None,
        developer_token=None,
        developer_token_provider=None,
        instance_id=None,
        profile=None,
        redirect_uri=None,
        region=None,
        refresh_token=None,
        scope=None,
        storage_adapter=None,
        storage_params=None,
        token_url=None,
        **kwargs
    ):
        &#34;&#34;&#34;Persist Session() and credentials attributes.

        The ``Credentials`` class is an abstraction layer for accessing,
        storing and refreshing credentials needed for interacting with
        the Application Framework.

        ``Credentials`` resolves credentials from the following locations,
        in the following order:

            1) Class instance variables
            2) Environment variables
            3) Credentials store

        Args:
            access_token (str): OAuth2 access token. Defaults to ``None``.
            auth_base_url (str): IdP base authorization URL. Default to ``None``.
            cache_token (bool): If ``True``, stores ``access_token`` in token store. Defaults to ``True``.
            client_id (str): OAuth2 client ID. Defaults to ``None``.
            client_secret (str): OAuth2 client secret. Defaults to ``None``.
            developer_token (str): Developer Token. Defaults to ``None``.
            developer_token_provider (str): Developer Token Provider URL. Defaults to ``None``.
            instance_id (str): Instance ID. Defaults to ``None``.
            profile (str): Credentials profile. Defaults to ``&#39;default&#39;``.
            redirect_uri (str): Redirect URI. Defaults to ``None``.
            region (str): Region. Defaults to ``None``.
            refresh_token (str): OAuth2 refresh token. Defaults to ``None``.
            scope (str): OAuth2 scope. Defaults to ``None``.
            storage_adapter (str): Namespace path to storage adapter module. Defaults to &#34;pan_cortex_data_lake.adapters.tinydb_adapter.TinyDBStore&#34;. 
            storage_params (dict) = Storage adapter parameters. Defaults to ``None``.
            token_url (str): Refresh URL. Defaults to ``None``.
            token_revoke_url (str): Revoke URL. Defaults to ``None``.
            **kwargs: Supported :class:`~requests.Session` parameters.

        &#34;&#34;&#34;
        self.access_token_ = access_token
        self.auth_base_url = auth_base_url or AUTH_BASE_URL
        self.cache_token_ = cache_token
        self.client_id_ = client_id
        self.client_secret_ = client_secret
        self.developer_token_ = developer_token
        self.developer_token_provider_ = developer_token_provider
        self.instance_id = instance_id
        self.jwt_exp_ = None
        self.profile = profile or &#34;default&#34;
        self.redirect_uri = redirect_uri
        self.region = region
        self.refresh_token_ = refresh_token
        self.scope = scope
        self.session = kwargs.pop(&#34;session&#34;, None)
        self.state = None
        self.adapter = (
            storage_adapter
            or &#34;pan_cortex_data_lake.adapters.tinydb_adapter.TinyDBStore&#34;
        )
        self.storage = self._init_adapter(storage_params)
        self.token_lock = Lock()
        self.token_url = token_url or API_BASE_URL
        self._credentials_found_in_instance = any(
            [
                self.access_token_,
                self.client_id_,
                self.client_secret_,
                self.refresh_token_,
            ]
        )
        self._httpclient = self.session or HTTPClient(**kwargs)

    def __repr__(self):
        args = self.__dict__.copy()
        for k in [
            &#34;access_token_&#34;,
            &#34;refresh_token_&#34;,
            &#34;client_secret_&#34;,
            &#34;developer_token_&#34;,
        ]:
            if args[k] is not None:
                args[k] = &#34;*&#34; * 6
        return &#34;{}({})&#34;.format(
            self.__class__.__name__, &#34;, &#34;.join(&#34;%s=%r&#34; % x for x in args.items()),
        )

    @property
    def access_token(self):
        &#34;&#34;&#34;Get access_token.&#34;&#34;&#34;
        if self.cache_token:
            return self.access_token_ or self._resolve_credential(&#34;access_token&#34;)
        return self.access_token_

    @access_token.setter
    def access_token(self, access_token):
        &#34;&#34;&#34;Set access_token.&#34;&#34;&#34;
        self.access_token_ = access_token

    @property
    def cache_token(self):
        &#34;&#34;&#34;Get cache_token setting.&#34;&#34;&#34;
        return self.cache_token_

    @property
    def client_id(self):
        &#34;&#34;&#34;Get client_id.&#34;&#34;&#34;
        return self.client_id_ or self._resolve_credential(&#34;client_id&#34;)

    @client_id.setter
    def client_id(self, client_id):
        &#34;&#34;&#34;Set client_id.&#34;&#34;&#34;
        self.client_id_ = client_id

    @property
    def client_secret(self):
        &#34;&#34;&#34;Get client_secret.&#34;&#34;&#34;
        return self.client_secret_ or self._resolve_credential(&#34;client_secret&#34;)

    @client_secret.setter
    def client_secret(self, client_secret):
        &#34;&#34;&#34;Set client_secret.&#34;&#34;&#34;
        self.client_secret_ = client_secret

    @property
    def developer_token(self):
        &#34;&#34;&#34;Get developer token.&#34;&#34;&#34;
        return self.developer_token_ or os.getenv(&#34;PAN_DEVELOPER_TOKEN&#34;)

    @developer_token.setter
    def developer_token(self, developer_token):
        &#34;&#34;&#34;Set developer token.&#34;&#34;&#34;
        self.developer_token_ = developer_token

    @property
    def developer_token_provider(self):
        &#34;&#34;&#34;Get developer token provider.&#34;&#34;&#34;
        return (
            self.developer_token_provider_
            or os.getenv(&#34;PAN_DEVELOPER_TOKEN_PROVIDER&#34;)
            or DEVELOPER_TOKEN_PROVIDER
        )

    @developer_token_provider.setter
    def developer_token_provider(self, developer_token_provider):
        &#34;&#34;&#34;Set developer token provider.&#34;&#34;&#34;
        self.developer_token_provider_ = developer_token_provider

    @property
    def jwt_exp(self):
        &#34;&#34;&#34;Get JWT exp.&#34;&#34;&#34;
        return self.jwt_exp_ or self._decode_exp()

    @jwt_exp.setter
    def jwt_exp(self, jwt_exp):
        &#34;&#34;&#34;Set jwt_exp.&#34;&#34;&#34;
        self.jwt_exp_ = jwt_exp

    @property
    def refresh_token(self):
        &#34;&#34;&#34;Get refresh_token.&#34;&#34;&#34;
        return self.refresh_token_ or self._resolve_credential(&#34;refresh_token&#34;)

    @refresh_token.setter
    def refresh_token(self, refresh_token):
        &#34;&#34;&#34;Set refresh_token.&#34;&#34;&#34;
        self.refresh_token_ = refresh_token

    @staticmethod
    def _credentials_found_in_envars():
        &#34;&#34;&#34;Check for credentials in envars.

        Returns:
            bool: ``True`` if at least one is found, otherwise ``False``.

        &#34;&#34;&#34;
        return any(
            [
                os.getenv(&#34;PAN_ACCESS_TOKEN&#34;),
                os.getenv(&#34;PAN_CLIENT_ID&#34;),
                os.getenv(&#34;PAN_CLIENT_SECRET&#34;),
                os.getenv(&#34;PAN_REFRESH_TOKEN&#34;),
            ]
        )

    def _init_adapter(self, storage_params=None):
        module_path = self.adapter.rsplit(&#34;.&#34;, 1)[0]
        adapter = self.adapter.split(&#34;.&#34;)[-1]
        try:
            __import__(module_path)
        except ImportError as e:
            raise CortexError(&#34;Module import error: %s: %s&#34; % (module_path, e))

        try:
            class_ = getattr(sys.modules[module_path], adapter)
        except AttributeError:
            raise CortexError(&#34;Class not found: %s&#34; % adapter)

        return class_(storage_params=storage_params)

    def _resolve_credential(self, credential):
        &#34;&#34;&#34;Resolve credential from envars or credentials store.

        Args:
            credential (str): Credential to resolve.

        Returns:
            str or None: Resolved credential or ``None``.

        &#34;&#34;&#34;
        if self._credentials_found_in_instance:
            return
        elif self._credentials_found_in_envars():
            return os.getenv(&#34;PAN_&#34; + credential.upper())
        else:
            return self.storage.fetch_credential(
                credential=credential, profile=self.profile
            )

    def decode_jwt_payload(self, access_token=None):
        &#34;&#34;&#34;Extract payload field from JWT.

        Args:
            access_token (str): Access token to decode. Defaults to ``None``.

        Returns:
            dict: JSON object that contains the claims conveyed by the JWT.

        &#34;&#34;&#34;
        c = self.get_credentials()
        jwt = access_token or c.access_token
        try:
            _, payload, _ = jwt.split(&#34;.&#34;)  # header, payload, sig
            rem = len(payload) % 4
            if rem &gt; 0:  # add padding
                payload += &#34;=&#34; * (4 - rem)
            try:
                decoded_jwt = b64decode(payload).decode(&#34;utf-8&#34;)
            except TypeError as e:
                raise CortexError(&#34;Failed to base64 decode JWT: %s&#34; % e)
            else:
                try:
                    x = loads(decoded_jwt)
                except ValueError as e:
                    raise CortexError(&#34;Invalid JSON: %s&#34; % e)
        except (AttributeError, ValueError) as e:
            raise CortexError(&#34;Invalid JWT: %s&#34; % e)

        return x

    def _decode_exp(self, access_token=None):
        &#34;&#34;&#34;Extract exp field from access token.

        Args:
            access_token (str): Access token to decode. Defaults to ``None``.

        Returns:
            int: JWT expiration in epoch seconds.

        &#34;&#34;&#34;
        c = self.get_credentials()
        jwt = access_token or c.access_token
        x = self.decode_jwt_payload(jwt)

        if &#34;exp&#34; in x:
            try:
                exp = int(x[&#34;exp&#34;])
            except ValueError:
                raise CortexError(&#34;Expiration time (exp) must be an integer&#34;)
            else:
                self.jwt_exp = exp
                return exp
        else:
            raise CortexError(&#34;No exp field found in payload&#34;)

    def fetch_tokens(
        self, client_id=None, client_secret=None, code=None, redirect_uri=None, **kwargs
    ):
        &#34;&#34;&#34;Exchange authorization code for token.

        Args:
            client_id (str): OAuth2 client ID. Defaults to ``None``.
            client_secret (str): OAuth2 client secret. Defaults to ``None``.
            code (str): Authorization code. Defaults to ``None``.
            redirect_uri (str): Redirect URI. Defaults to ``None``.

        Returns:
            dict: Response from token URL.

        &#34;&#34;&#34;
        client_id = client_id or self.client_id
        client_secret = client_secret or self.client_secret
        redirect_uri = redirect_uri or self.redirect_uri
        data = {
            &#34;grant_type&#34;: &#34;authorization_code&#34;,
            &#34;client_id&#34;: client_id,
            &#34;client_secret&#34;: client_secret,
            &#34;code&#34;: code,
            &#34;redirect_uri&#34;: redirect_uri,
        }
        r = self._httpclient.request(
            method=&#34;POST&#34;,
            url=self.token_url,
            json=data,
            endpoint=&#34;/api/oauth2/RequestToken&#34;,
            auth=None,
            **kwargs
        )
        if not r.ok:
            raise CortexError(&#34;%s %s: %s&#34; % (r.status_code, r.reason, r.text))
        try:
            r_json = r.json()
        except ValueError as e:
            raise CortexError(&#34;Invalid JSON: %s&#34; % e)
        else:
            if r.json().get(&#34;error_description&#34;) or r.json().get(&#34;error&#34;):
                raise CortexError(r.text)
            self.access_token = r_json.get(&#34;access_token&#34;)
            self.jwt_exp = self._decode_exp(self.access_token_)
            self.refresh_token = r_json.get(&#34;refresh_token&#34;)
            self.write_credentials()
            return r_json

    def get_authorization_url(
        self,
        client_id=None,
        instance_id=None,
        redirect_uri=None,
        region=None,
        scope=None,
        state=None,
    ):
        &#34;&#34;&#34;Generate authorization URL.

        Args:
            client_id (str): OAuth2 client ID. Defaults to ``None``.
            instance_id (str): App Instance ID. Defaults to ``None``.
            redirect_uri (str): Redirect URI. Defaults to ``None``.
            region (str): App Region. Defaults to ``None``.
            scope (str): Permissions. Defaults to ``None``.
            state (str): UUID to detect CSRF. Defaults to ``None``.

        Returns:
            str, str: Auth URL, state

        &#34;&#34;&#34;
        client_id = client_id or self.client_id
        instance_id = instance_id or self.instance_id
        redirect_uri = redirect_uri or self.redirect_uri
        region = region or self.region
        scope = scope or self.scope
        state = state or str(uuid.uuid4())
        self.state = state
        return (
            Request(
                &#34;GET&#34;,
                self.auth_base_url,
                params={
                    &#34;client_id&#34;: client_id,
                    &#34;instance_id&#34;: instance_id,
                    &#34;redirect_uri&#34;: redirect_uri,
                    &#34;region&#34;: region,
                    &#34;response_type&#34;: &#34;code&#34;,
                    &#34;scope&#34;: scope,
                    &#34;state&#34;: state,
                },
            )
            .prepare()
            .url,
            state,
        )

    def get_credentials(self):
        &#34;&#34;&#34;Get read-only credentials.

        Returns:
            class: Read-only credentials.

        &#34;&#34;&#34;
        return ReadOnlyCredentials(
            self.access_token, self.client_id, self.client_secret, self.refresh_token
        )

    def jwt_is_expired(self, access_token=None, leeway=0):
        &#34;&#34;&#34;Validate JWT access token expiration.

        Args:
            access_token (str): Access token to validate. Defaults to ``None``.
            leeway (float): Time in seconds to adjust for local clock skew. Defaults to 0.

        Returns:
            bool: ``True`` if expired, otherwise ``False``.

        &#34;&#34;&#34;
        if access_token is not None:
            exp = self._decode_exp(access_token)
        else:
            exp = self.jwt_exp
        now = time()
        if exp &lt; (now - leeway):
            return True
        return False

    def remove_profile(self, profile):
        &#34;&#34;&#34;Remove profile from credentials store.

        Args:
            profile (str): Credentials profile to remove.

        Returns:
            Return value of self.storage.remove_profile()

        &#34;&#34;&#34;
        return self.storage.remove_profile(profile=profile)

    def refresh(self, access_token=None, **kwargs):
        &#34;&#34;&#34;Refresh access and refresh tokens.

        Args:
            access_token (str): Access token to refresh. Defaults to ``None``.

        Returns:
            str: Refreshed access token.

        &#34;&#34;&#34;
        if not self.token_lock.locked():
            with self.token_lock:
                if access_token == self.access_token or access_token is None:
                    if self.developer_token is not None and not any(
                        [
                            os.getenv(&#34;PAN_ACCESS_TOKEN&#34;),
                            self._credentials_found_in_instance,
                        ]
                    ):
                        parsed_provider = urlparse(self.developer_token_provider)
                        url = &#34;{}://{}&#34;.format(
                            parsed_provider.scheme, parsed_provider.netloc
                        )
                        endpoint = parsed_provider.path
                        r = self._httpclient.request(
                            method=&#34;POST&#34;,
                            url=url,
                            endpoint=endpoint,
                            headers={
                                &#34;Authorization&#34;: &#34;Bearer {}&#34;.format(
                                    self.developer_token
                                )
                            },
                            timeout=30,
                            raise_for_status=True,
                        )

                    elif all([self.client_id, self.client_secret, self.refresh_token]):
                        data = {
                            &#34;client_id&#34;: self.client_id,
                            &#34;client_secret&#34;: self.client_secret,
                            &#34;refresh_token&#34;: self.refresh_token,
                            &#34;grant_type&#34;: &#34;refresh_token&#34;,
                        }
                        r = self._httpclient.request(
                            method=&#34;POST&#34;,
                            url=self.token_url,
                            json=data,
                            endpoint=&#34;/api/oauth2/RequestToken&#34;,
                            **kwargs
                        )
                    else:
                        raise PartialCredentialsError(
                            &#34;Missing one or more required credentials&#34;
                        )

                    if r:
                        if not r.ok:
                            raise CortexError(
                                &#34;%s %s: %s&#34; % (r.status_code, r.reason, r.text)
                            )
                        try:
                            r_json = r.json()
                        except ValueError as e:
                            raise CortexError(&#34;Invalid JSON: %s&#34; % e)
                        else:
                            if r.json().get(&#34;error_description&#34;) or r.json().get(
                                &#34;error&#34;
                            ):
                                raise CortexError(r.text)
                            self.access_token = r_json.get(&#34;access_token&#34;, None)
                            self.jwt_exp = self._decode_exp(self.access_token_)
                            if r_json.get(&#34;refresh_token&#34;, None):
                                self.refresh_token = r_json.get(&#34;refresh_token&#34;)
                            self.write_credentials()
                        return self.access_token_

    def revoke_access_token(self, **kwargs):
        &#34;&#34;&#34;Revoke access token.&#34;&#34;&#34;
        c = self.get_credentials()
        data = {
            &#34;client_id&#34;: c.client_id,
            &#34;client_secret&#34;: c.client_secret,
            &#34;token&#34;: c.access_token,
            &#34;token_type_hint&#34;: &#34;access_token&#34;,
        }
        r = self._httpclient.request(
            method=&#34;POST&#34;,
            url=self.token_url,
            json=data,
            endpoint=&#34;/api/oauth2/RevokeToken&#34;,
            **kwargs
        )
        if not r.ok:
            raise CortexError(&#34;%s %s: %s&#34; % (r.status_code, r.reason, r.text))
        try:
            r_json = r.json()
        except ValueError as e:
            raise CortexError(&#34;Invalid JSON: %s&#34; % e)
        else:
            if r.json().get(&#34;error_description&#34;) or r.json().get(&#34;error&#34;):
                raise CortexError(r.text)
            return r_json

    def revoke_refresh_token(self, **kwargs):
        &#34;&#34;&#34;Revoke refresh token.&#34;&#34;&#34;
        c = self.get_credentials()
        data = {
            &#34;client_id&#34;: c.client_id,
            &#34;client_secret&#34;: c.client_secret,
            &#34;token&#34;: c.refresh_token,
            &#34;token_type_hint&#34;: &#34;refresh_token&#34;,
        }
        r = self._httpclient.request(
            method=&#34;POST&#34;,
            url=self.token_url,
            json=data,
            endpoint=&#34;/api/oauth2/RevokeToken&#34;,
            **kwargs
        )
        if not r.ok:
            raise CortexError(&#34;%s %s: %s&#34; % (r.status_code, r.reason, r.text))
        try:
            r_json = r.json()
        except ValueError as e:
            raise CortexError(&#34;Invalid JSON: %s&#34; % e)
        else:
            if r.json().get(&#34;error_description&#34;) or r.json().get(&#34;error&#34;):
                raise CortexError(r.text)
            return r_json

    def write_credentials(self):
        &#34;&#34;&#34;Write credentials.

        Write credentials to credentials store.

        Returns:
            Return value of self.storage.write_credentials()

        &#34;&#34;&#34;
        c = self.get_credentials()
        return self.storage.write_credentials(
            credentials=c, profile=self.profile, cache_token=self.cache_token
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pan_cortex_data_lake.credentials.Credentials"><code class="flex name class">
<span>class <span class="ident">Credentials</span></span>
<span>(</span><span>access_token=None, auth_base_url=None, cache_token=True, client_id=None, client_secret=None, developer_token=None, developer_token_provider=None, instance_id=None, profile=None, redirect_uri=None, region=None, refresh_token=None, scope=None, storage_adapter=None, storage_params=None, token_url=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>An Application Framework credentials object.</p>
<p>Persist Session() and credentials attributes.</p>
<p>The <code><a title="pan_cortex_data_lake.credentials.Credentials" href="#pan_cortex_data_lake.credentials.Credentials">Credentials</a></code> class is an abstraction layer for accessing,
storing and refreshing credentials needed for interacting with
the Application Framework.</p>
<p><code><a title="pan_cortex_data_lake.credentials.Credentials" href="#pan_cortex_data_lake.credentials.Credentials">Credentials</a></code> resolves credentials from the following locations,
in the following order:</p>
<pre><code>1) Class instance variables
2) Environment variables
3) Credentials store
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>access_token</code></strong> :&ensp;<code>str</code></dt>
<dd>OAuth2 access token. Defaults to <code>None</code>.</dd>
<dt><strong><code>auth_base_url</code></strong> :&ensp;<code>str</code></dt>
<dd>IdP base authorization URL. Default to <code>None</code>.</dd>
<dt><strong><code>cache_token</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code>, stores <code>access_token</code> in token store. Defaults to <code>True</code>.</dd>
<dt><strong><code>client_id</code></strong> :&ensp;<code>str</code></dt>
<dd>OAuth2 client ID. Defaults to <code>None</code>.</dd>
<dt><strong><code>client_secret</code></strong> :&ensp;<code>str</code></dt>
<dd>OAuth2 client secret. Defaults to <code>None</code>.</dd>
<dt><strong><code>developer_token</code></strong> :&ensp;<code>str</code></dt>
<dd>Developer Token. Defaults to <code>None</code>.</dd>
<dt><strong><code>developer_token_provider</code></strong> :&ensp;<code>str</code></dt>
<dd>Developer Token Provider URL. Defaults to <code>None</code>.</dd>
<dt><strong><code>instance_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Instance ID. Defaults to <code>None</code>.</dd>
<dt><strong><code>profile</code></strong> :&ensp;<code>str</code></dt>
<dd>Credentials profile. Defaults to <code>'default'</code>.</dd>
<dt><strong><code>redirect_uri</code></strong> :&ensp;<code>str</code></dt>
<dd>Redirect URI. Defaults to <code>None</code>.</dd>
<dt><strong><code>region</code></strong> :&ensp;<code>str</code></dt>
<dd>Region. Defaults to <code>None</code>.</dd>
<dt><strong><code>refresh_token</code></strong> :&ensp;<code>str</code></dt>
<dd>OAuth2 refresh token. Defaults to <code>None</code>.</dd>
<dt><strong><code>scope</code></strong> :&ensp;<code>str</code></dt>
<dd>OAuth2 scope. Defaults to <code>None</code>.</dd>
<dt><strong><code>storage_adapter</code></strong> :&ensp;<code>str</code></dt>
<dd>Namespace path to storage adapter module. Defaults to "pan_cortex_data_lake.adapters.tinydb_adapter.TinyDBStore". </dd>
<dt>storage_params (dict) = Storage adapter parameters. Defaults to <code>None</code>.</dt>
<dt><strong><code>token_url</code></strong> :&ensp;<code>str</code></dt>
<dd>Refresh URL. Defaults to <code>None</code>.</dd>
<dt><strong><code>token_revoke_url</code></strong> :&ensp;<code>str</code></dt>
<dd>Revoke URL. Defaults to <code>None</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Supported :class:<code>~requests.Session</code> parameters.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Credentials(object):
    &#34;&#34;&#34;An Application Framework credentials object.&#34;&#34;&#34;

    def __init__(
        self,
        access_token=None,
        auth_base_url=None,
        cache_token=True,
        client_id=None,
        client_secret=None,
        developer_token=None,
        developer_token_provider=None,
        instance_id=None,
        profile=None,
        redirect_uri=None,
        region=None,
        refresh_token=None,
        scope=None,
        storage_adapter=None,
        storage_params=None,
        token_url=None,
        **kwargs
    ):
        &#34;&#34;&#34;Persist Session() and credentials attributes.

        The ``Credentials`` class is an abstraction layer for accessing,
        storing and refreshing credentials needed for interacting with
        the Application Framework.

        ``Credentials`` resolves credentials from the following locations,
        in the following order:

            1) Class instance variables
            2) Environment variables
            3) Credentials store

        Args:
            access_token (str): OAuth2 access token. Defaults to ``None``.
            auth_base_url (str): IdP base authorization URL. Default to ``None``.
            cache_token (bool): If ``True``, stores ``access_token`` in token store. Defaults to ``True``.
            client_id (str): OAuth2 client ID. Defaults to ``None``.
            client_secret (str): OAuth2 client secret. Defaults to ``None``.
            developer_token (str): Developer Token. Defaults to ``None``.
            developer_token_provider (str): Developer Token Provider URL. Defaults to ``None``.
            instance_id (str): Instance ID. Defaults to ``None``.
            profile (str): Credentials profile. Defaults to ``&#39;default&#39;``.
            redirect_uri (str): Redirect URI. Defaults to ``None``.
            region (str): Region. Defaults to ``None``.
            refresh_token (str): OAuth2 refresh token. Defaults to ``None``.
            scope (str): OAuth2 scope. Defaults to ``None``.
            storage_adapter (str): Namespace path to storage adapter module. Defaults to &#34;pan_cortex_data_lake.adapters.tinydb_adapter.TinyDBStore&#34;. 
            storage_params (dict) = Storage adapter parameters. Defaults to ``None``.
            token_url (str): Refresh URL. Defaults to ``None``.
            token_revoke_url (str): Revoke URL. Defaults to ``None``.
            **kwargs: Supported :class:`~requests.Session` parameters.

        &#34;&#34;&#34;
        self.access_token_ = access_token
        self.auth_base_url = auth_base_url or AUTH_BASE_URL
        self.cache_token_ = cache_token
        self.client_id_ = client_id
        self.client_secret_ = client_secret
        self.developer_token_ = developer_token
        self.developer_token_provider_ = developer_token_provider
        self.instance_id = instance_id
        self.jwt_exp_ = None
        self.profile = profile or &#34;default&#34;
        self.redirect_uri = redirect_uri
        self.region = region
        self.refresh_token_ = refresh_token
        self.scope = scope
        self.session = kwargs.pop(&#34;session&#34;, None)
        self.state = None
        self.adapter = (
            storage_adapter
            or &#34;pan_cortex_data_lake.adapters.tinydb_adapter.TinyDBStore&#34;
        )
        self.storage = self._init_adapter(storage_params)
        self.token_lock = Lock()
        self.token_url = token_url or API_BASE_URL
        self._credentials_found_in_instance = any(
            [
                self.access_token_,
                self.client_id_,
                self.client_secret_,
                self.refresh_token_,
            ]
        )
        self._httpclient = self.session or HTTPClient(**kwargs)

    def __repr__(self):
        args = self.__dict__.copy()
        for k in [
            &#34;access_token_&#34;,
            &#34;refresh_token_&#34;,
            &#34;client_secret_&#34;,
            &#34;developer_token_&#34;,
        ]:
            if args[k] is not None:
                args[k] = &#34;*&#34; * 6
        return &#34;{}({})&#34;.format(
            self.__class__.__name__, &#34;, &#34;.join(&#34;%s=%r&#34; % x for x in args.items()),
        )

    @property
    def access_token(self):
        &#34;&#34;&#34;Get access_token.&#34;&#34;&#34;
        if self.cache_token:
            return self.access_token_ or self._resolve_credential(&#34;access_token&#34;)
        return self.access_token_

    @access_token.setter
    def access_token(self, access_token):
        &#34;&#34;&#34;Set access_token.&#34;&#34;&#34;
        self.access_token_ = access_token

    @property
    def cache_token(self):
        &#34;&#34;&#34;Get cache_token setting.&#34;&#34;&#34;
        return self.cache_token_

    @property
    def client_id(self):
        &#34;&#34;&#34;Get client_id.&#34;&#34;&#34;
        return self.client_id_ or self._resolve_credential(&#34;client_id&#34;)

    @client_id.setter
    def client_id(self, client_id):
        &#34;&#34;&#34;Set client_id.&#34;&#34;&#34;
        self.client_id_ = client_id

    @property
    def client_secret(self):
        &#34;&#34;&#34;Get client_secret.&#34;&#34;&#34;
        return self.client_secret_ or self._resolve_credential(&#34;client_secret&#34;)

    @client_secret.setter
    def client_secret(self, client_secret):
        &#34;&#34;&#34;Set client_secret.&#34;&#34;&#34;
        self.client_secret_ = client_secret

    @property
    def developer_token(self):
        &#34;&#34;&#34;Get developer token.&#34;&#34;&#34;
        return self.developer_token_ or os.getenv(&#34;PAN_DEVELOPER_TOKEN&#34;)

    @developer_token.setter
    def developer_token(self, developer_token):
        &#34;&#34;&#34;Set developer token.&#34;&#34;&#34;
        self.developer_token_ = developer_token

    @property
    def developer_token_provider(self):
        &#34;&#34;&#34;Get developer token provider.&#34;&#34;&#34;
        return (
            self.developer_token_provider_
            or os.getenv(&#34;PAN_DEVELOPER_TOKEN_PROVIDER&#34;)
            or DEVELOPER_TOKEN_PROVIDER
        )

    @developer_token_provider.setter
    def developer_token_provider(self, developer_token_provider):
        &#34;&#34;&#34;Set developer token provider.&#34;&#34;&#34;
        self.developer_token_provider_ = developer_token_provider

    @property
    def jwt_exp(self):
        &#34;&#34;&#34;Get JWT exp.&#34;&#34;&#34;
        return self.jwt_exp_ or self._decode_exp()

    @jwt_exp.setter
    def jwt_exp(self, jwt_exp):
        &#34;&#34;&#34;Set jwt_exp.&#34;&#34;&#34;
        self.jwt_exp_ = jwt_exp

    @property
    def refresh_token(self):
        &#34;&#34;&#34;Get refresh_token.&#34;&#34;&#34;
        return self.refresh_token_ or self._resolve_credential(&#34;refresh_token&#34;)

    @refresh_token.setter
    def refresh_token(self, refresh_token):
        &#34;&#34;&#34;Set refresh_token.&#34;&#34;&#34;
        self.refresh_token_ = refresh_token

    @staticmethod
    def _credentials_found_in_envars():
        &#34;&#34;&#34;Check for credentials in envars.

        Returns:
            bool: ``True`` if at least one is found, otherwise ``False``.

        &#34;&#34;&#34;
        return any(
            [
                os.getenv(&#34;PAN_ACCESS_TOKEN&#34;),
                os.getenv(&#34;PAN_CLIENT_ID&#34;),
                os.getenv(&#34;PAN_CLIENT_SECRET&#34;),
                os.getenv(&#34;PAN_REFRESH_TOKEN&#34;),
            ]
        )

    def _init_adapter(self, storage_params=None):
        module_path = self.adapter.rsplit(&#34;.&#34;, 1)[0]
        adapter = self.adapter.split(&#34;.&#34;)[-1]
        try:
            __import__(module_path)
        except ImportError as e:
            raise CortexError(&#34;Module import error: %s: %s&#34; % (module_path, e))

        try:
            class_ = getattr(sys.modules[module_path], adapter)
        except AttributeError:
            raise CortexError(&#34;Class not found: %s&#34; % adapter)

        return class_(storage_params=storage_params)

    def _resolve_credential(self, credential):
        &#34;&#34;&#34;Resolve credential from envars or credentials store.

        Args:
            credential (str): Credential to resolve.

        Returns:
            str or None: Resolved credential or ``None``.

        &#34;&#34;&#34;
        if self._credentials_found_in_instance:
            return
        elif self._credentials_found_in_envars():
            return os.getenv(&#34;PAN_&#34; + credential.upper())
        else:
            return self.storage.fetch_credential(
                credential=credential, profile=self.profile
            )

    def decode_jwt_payload(self, access_token=None):
        &#34;&#34;&#34;Extract payload field from JWT.

        Args:
            access_token (str): Access token to decode. Defaults to ``None``.

        Returns:
            dict: JSON object that contains the claims conveyed by the JWT.

        &#34;&#34;&#34;
        c = self.get_credentials()
        jwt = access_token or c.access_token
        try:
            _, payload, _ = jwt.split(&#34;.&#34;)  # header, payload, sig
            rem = len(payload) % 4
            if rem &gt; 0:  # add padding
                payload += &#34;=&#34; * (4 - rem)
            try:
                decoded_jwt = b64decode(payload).decode(&#34;utf-8&#34;)
            except TypeError as e:
                raise CortexError(&#34;Failed to base64 decode JWT: %s&#34; % e)
            else:
                try:
                    x = loads(decoded_jwt)
                except ValueError as e:
                    raise CortexError(&#34;Invalid JSON: %s&#34; % e)
        except (AttributeError, ValueError) as e:
            raise CortexError(&#34;Invalid JWT: %s&#34; % e)

        return x

    def _decode_exp(self, access_token=None):
        &#34;&#34;&#34;Extract exp field from access token.

        Args:
            access_token (str): Access token to decode. Defaults to ``None``.

        Returns:
            int: JWT expiration in epoch seconds.

        &#34;&#34;&#34;
        c = self.get_credentials()
        jwt = access_token or c.access_token
        x = self.decode_jwt_payload(jwt)

        if &#34;exp&#34; in x:
            try:
                exp = int(x[&#34;exp&#34;])
            except ValueError:
                raise CortexError(&#34;Expiration time (exp) must be an integer&#34;)
            else:
                self.jwt_exp = exp
                return exp
        else:
            raise CortexError(&#34;No exp field found in payload&#34;)

    def fetch_tokens(
        self, client_id=None, client_secret=None, code=None, redirect_uri=None, **kwargs
    ):
        &#34;&#34;&#34;Exchange authorization code for token.

        Args:
            client_id (str): OAuth2 client ID. Defaults to ``None``.
            client_secret (str): OAuth2 client secret. Defaults to ``None``.
            code (str): Authorization code. Defaults to ``None``.
            redirect_uri (str): Redirect URI. Defaults to ``None``.

        Returns:
            dict: Response from token URL.

        &#34;&#34;&#34;
        client_id = client_id or self.client_id
        client_secret = client_secret or self.client_secret
        redirect_uri = redirect_uri or self.redirect_uri
        data = {
            &#34;grant_type&#34;: &#34;authorization_code&#34;,
            &#34;client_id&#34;: client_id,
            &#34;client_secret&#34;: client_secret,
            &#34;code&#34;: code,
            &#34;redirect_uri&#34;: redirect_uri,
        }
        r = self._httpclient.request(
            method=&#34;POST&#34;,
            url=self.token_url,
            json=data,
            endpoint=&#34;/api/oauth2/RequestToken&#34;,
            auth=None,
            **kwargs
        )
        if not r.ok:
            raise CortexError(&#34;%s %s: %s&#34; % (r.status_code, r.reason, r.text))
        try:
            r_json = r.json()
        except ValueError as e:
            raise CortexError(&#34;Invalid JSON: %s&#34; % e)
        else:
            if r.json().get(&#34;error_description&#34;) or r.json().get(&#34;error&#34;):
                raise CortexError(r.text)
            self.access_token = r_json.get(&#34;access_token&#34;)
            self.jwt_exp = self._decode_exp(self.access_token_)
            self.refresh_token = r_json.get(&#34;refresh_token&#34;)
            self.write_credentials()
            return r_json

    def get_authorization_url(
        self,
        client_id=None,
        instance_id=None,
        redirect_uri=None,
        region=None,
        scope=None,
        state=None,
    ):
        &#34;&#34;&#34;Generate authorization URL.

        Args:
            client_id (str): OAuth2 client ID. Defaults to ``None``.
            instance_id (str): App Instance ID. Defaults to ``None``.
            redirect_uri (str): Redirect URI. Defaults to ``None``.
            region (str): App Region. Defaults to ``None``.
            scope (str): Permissions. Defaults to ``None``.
            state (str): UUID to detect CSRF. Defaults to ``None``.

        Returns:
            str, str: Auth URL, state

        &#34;&#34;&#34;
        client_id = client_id or self.client_id
        instance_id = instance_id or self.instance_id
        redirect_uri = redirect_uri or self.redirect_uri
        region = region or self.region
        scope = scope or self.scope
        state = state or str(uuid.uuid4())
        self.state = state
        return (
            Request(
                &#34;GET&#34;,
                self.auth_base_url,
                params={
                    &#34;client_id&#34;: client_id,
                    &#34;instance_id&#34;: instance_id,
                    &#34;redirect_uri&#34;: redirect_uri,
                    &#34;region&#34;: region,
                    &#34;response_type&#34;: &#34;code&#34;,
                    &#34;scope&#34;: scope,
                    &#34;state&#34;: state,
                },
            )
            .prepare()
            .url,
            state,
        )

    def get_credentials(self):
        &#34;&#34;&#34;Get read-only credentials.

        Returns:
            class: Read-only credentials.

        &#34;&#34;&#34;
        return ReadOnlyCredentials(
            self.access_token, self.client_id, self.client_secret, self.refresh_token
        )

    def jwt_is_expired(self, access_token=None, leeway=0):
        &#34;&#34;&#34;Validate JWT access token expiration.

        Args:
            access_token (str): Access token to validate. Defaults to ``None``.
            leeway (float): Time in seconds to adjust for local clock skew. Defaults to 0.

        Returns:
            bool: ``True`` if expired, otherwise ``False``.

        &#34;&#34;&#34;
        if access_token is not None:
            exp = self._decode_exp(access_token)
        else:
            exp = self.jwt_exp
        now = time()
        if exp &lt; (now - leeway):
            return True
        return False

    def remove_profile(self, profile):
        &#34;&#34;&#34;Remove profile from credentials store.

        Args:
            profile (str): Credentials profile to remove.

        Returns:
            Return value of self.storage.remove_profile()

        &#34;&#34;&#34;
        return self.storage.remove_profile(profile=profile)

    def refresh(self, access_token=None, **kwargs):
        &#34;&#34;&#34;Refresh access and refresh tokens.

        Args:
            access_token (str): Access token to refresh. Defaults to ``None``.

        Returns:
            str: Refreshed access token.

        &#34;&#34;&#34;
        if not self.token_lock.locked():
            with self.token_lock:
                if access_token == self.access_token or access_token is None:
                    if self.developer_token is not None and not any(
                        [
                            os.getenv(&#34;PAN_ACCESS_TOKEN&#34;),
                            self._credentials_found_in_instance,
                        ]
                    ):
                        parsed_provider = urlparse(self.developer_token_provider)
                        url = &#34;{}://{}&#34;.format(
                            parsed_provider.scheme, parsed_provider.netloc
                        )
                        endpoint = parsed_provider.path
                        r = self._httpclient.request(
                            method=&#34;POST&#34;,
                            url=url,
                            endpoint=endpoint,
                            headers={
                                &#34;Authorization&#34;: &#34;Bearer {}&#34;.format(
                                    self.developer_token
                                )
                            },
                            timeout=30,
                            raise_for_status=True,
                        )

                    elif all([self.client_id, self.client_secret, self.refresh_token]):
                        data = {
                            &#34;client_id&#34;: self.client_id,
                            &#34;client_secret&#34;: self.client_secret,
                            &#34;refresh_token&#34;: self.refresh_token,
                            &#34;grant_type&#34;: &#34;refresh_token&#34;,
                        }
                        r = self._httpclient.request(
                            method=&#34;POST&#34;,
                            url=self.token_url,
                            json=data,
                            endpoint=&#34;/api/oauth2/RequestToken&#34;,
                            **kwargs
                        )
                    else:
                        raise PartialCredentialsError(
                            &#34;Missing one or more required credentials&#34;
                        )

                    if r:
                        if not r.ok:
                            raise CortexError(
                                &#34;%s %s: %s&#34; % (r.status_code, r.reason, r.text)
                            )
                        try:
                            r_json = r.json()
                        except ValueError as e:
                            raise CortexError(&#34;Invalid JSON: %s&#34; % e)
                        else:
                            if r.json().get(&#34;error_description&#34;) or r.json().get(
                                &#34;error&#34;
                            ):
                                raise CortexError(r.text)
                            self.access_token = r_json.get(&#34;access_token&#34;, None)
                            self.jwt_exp = self._decode_exp(self.access_token_)
                            if r_json.get(&#34;refresh_token&#34;, None):
                                self.refresh_token = r_json.get(&#34;refresh_token&#34;)
                            self.write_credentials()
                        return self.access_token_

    def revoke_access_token(self, **kwargs):
        &#34;&#34;&#34;Revoke access token.&#34;&#34;&#34;
        c = self.get_credentials()
        data = {
            &#34;client_id&#34;: c.client_id,
            &#34;client_secret&#34;: c.client_secret,
            &#34;token&#34;: c.access_token,
            &#34;token_type_hint&#34;: &#34;access_token&#34;,
        }
        r = self._httpclient.request(
            method=&#34;POST&#34;,
            url=self.token_url,
            json=data,
            endpoint=&#34;/api/oauth2/RevokeToken&#34;,
            **kwargs
        )
        if not r.ok:
            raise CortexError(&#34;%s %s: %s&#34; % (r.status_code, r.reason, r.text))
        try:
            r_json = r.json()
        except ValueError as e:
            raise CortexError(&#34;Invalid JSON: %s&#34; % e)
        else:
            if r.json().get(&#34;error_description&#34;) or r.json().get(&#34;error&#34;):
                raise CortexError(r.text)
            return r_json

    def revoke_refresh_token(self, **kwargs):
        &#34;&#34;&#34;Revoke refresh token.&#34;&#34;&#34;
        c = self.get_credentials()
        data = {
            &#34;client_id&#34;: c.client_id,
            &#34;client_secret&#34;: c.client_secret,
            &#34;token&#34;: c.refresh_token,
            &#34;token_type_hint&#34;: &#34;refresh_token&#34;,
        }
        r = self._httpclient.request(
            method=&#34;POST&#34;,
            url=self.token_url,
            json=data,
            endpoint=&#34;/api/oauth2/RevokeToken&#34;,
            **kwargs
        )
        if not r.ok:
            raise CortexError(&#34;%s %s: %s&#34; % (r.status_code, r.reason, r.text))
        try:
            r_json = r.json()
        except ValueError as e:
            raise CortexError(&#34;Invalid JSON: %s&#34; % e)
        else:
            if r.json().get(&#34;error_description&#34;) or r.json().get(&#34;error&#34;):
                raise CortexError(r.text)
            return r_json

    def write_credentials(self):
        &#34;&#34;&#34;Write credentials.

        Write credentials to credentials store.

        Returns:
            Return value of self.storage.write_credentials()

        &#34;&#34;&#34;
        c = self.get_credentials()
        return self.storage.write_credentials(
            credentials=c, profile=self.profile, cache_token=self.cache_token
        )</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pan_cortex_data_lake.credentials.Credentials.access_token"><code class="name">var <span class="ident">access_token</span></code></dt>
<dd>
<div class="desc"><p>Get access_token.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def access_token(self):
    &#34;&#34;&#34;Get access_token.&#34;&#34;&#34;
    if self.cache_token:
        return self.access_token_ or self._resolve_credential(&#34;access_token&#34;)
    return self.access_token_</code></pre>
</details>
</dd>
<dt id="pan_cortex_data_lake.credentials.Credentials.cache_token"><code class="name">var <span class="ident">cache_token</span></code></dt>
<dd>
<div class="desc"><p>Get cache_token setting.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cache_token(self):
    &#34;&#34;&#34;Get cache_token setting.&#34;&#34;&#34;
    return self.cache_token_</code></pre>
</details>
</dd>
<dt id="pan_cortex_data_lake.credentials.Credentials.client_id"><code class="name">var <span class="ident">client_id</span></code></dt>
<dd>
<div class="desc"><p>Get client_id.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def client_id(self):
    &#34;&#34;&#34;Get client_id.&#34;&#34;&#34;
    return self.client_id_ or self._resolve_credential(&#34;client_id&#34;)</code></pre>
</details>
</dd>
<dt id="pan_cortex_data_lake.credentials.Credentials.client_secret"><code class="name">var <span class="ident">client_secret</span></code></dt>
<dd>
<div class="desc"><p>Get client_secret.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def client_secret(self):
    &#34;&#34;&#34;Get client_secret.&#34;&#34;&#34;
    return self.client_secret_ or self._resolve_credential(&#34;client_secret&#34;)</code></pre>
</details>
</dd>
<dt id="pan_cortex_data_lake.credentials.Credentials.developer_token"><code class="name">var <span class="ident">developer_token</span></code></dt>
<dd>
<div class="desc"><p>Get developer token.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def developer_token(self):
    &#34;&#34;&#34;Get developer token.&#34;&#34;&#34;
    return self.developer_token_ or os.getenv(&#34;PAN_DEVELOPER_TOKEN&#34;)</code></pre>
</details>
</dd>
<dt id="pan_cortex_data_lake.credentials.Credentials.developer_token_provider"><code class="name">var <span class="ident">developer_token_provider</span></code></dt>
<dd>
<div class="desc"><p>Get developer token provider.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def developer_token_provider(self):
    &#34;&#34;&#34;Get developer token provider.&#34;&#34;&#34;
    return (
        self.developer_token_provider_
        or os.getenv(&#34;PAN_DEVELOPER_TOKEN_PROVIDER&#34;)
        or DEVELOPER_TOKEN_PROVIDER
    )</code></pre>
</details>
</dd>
<dt id="pan_cortex_data_lake.credentials.Credentials.jwt_exp"><code class="name">var <span class="ident">jwt_exp</span></code></dt>
<dd>
<div class="desc"><p>Get JWT exp.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def jwt_exp(self):
    &#34;&#34;&#34;Get JWT exp.&#34;&#34;&#34;
    return self.jwt_exp_ or self._decode_exp()</code></pre>
</details>
</dd>
<dt id="pan_cortex_data_lake.credentials.Credentials.refresh_token"><code class="name">var <span class="ident">refresh_token</span></code></dt>
<dd>
<div class="desc"><p>Get refresh_token.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def refresh_token(self):
    &#34;&#34;&#34;Get refresh_token.&#34;&#34;&#34;
    return self.refresh_token_ or self._resolve_credential(&#34;refresh_token&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pan_cortex_data_lake.credentials.Credentials.decode_jwt_payload"><code class="name flex">
<span>def <span class="ident">decode_jwt_payload</span></span>(<span>self, access_token=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract payload field from JWT.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>access_token</code></strong> :&ensp;<code>str</code></dt>
<dd>Access token to decode. Defaults to <code>None</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>JSON object that contains the claims conveyed by the JWT.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_jwt_payload(self, access_token=None):
    &#34;&#34;&#34;Extract payload field from JWT.

    Args:
        access_token (str): Access token to decode. Defaults to ``None``.

    Returns:
        dict: JSON object that contains the claims conveyed by the JWT.

    &#34;&#34;&#34;
    c = self.get_credentials()
    jwt = access_token or c.access_token
    try:
        _, payload, _ = jwt.split(&#34;.&#34;)  # header, payload, sig
        rem = len(payload) % 4
        if rem &gt; 0:  # add padding
            payload += &#34;=&#34; * (4 - rem)
        try:
            decoded_jwt = b64decode(payload).decode(&#34;utf-8&#34;)
        except TypeError as e:
            raise CortexError(&#34;Failed to base64 decode JWT: %s&#34; % e)
        else:
            try:
                x = loads(decoded_jwt)
            except ValueError as e:
                raise CortexError(&#34;Invalid JSON: %s&#34; % e)
    except (AttributeError, ValueError) as e:
        raise CortexError(&#34;Invalid JWT: %s&#34; % e)

    return x</code></pre>
</details>
</dd>
<dt id="pan_cortex_data_lake.credentials.Credentials.fetch_tokens"><code class="name flex">
<span>def <span class="ident">fetch_tokens</span></span>(<span>self, client_id=None, client_secret=None, code=None, redirect_uri=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Exchange authorization code for token.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>client_id</code></strong> :&ensp;<code>str</code></dt>
<dd>OAuth2 client ID. Defaults to <code>None</code>.</dd>
<dt><strong><code>client_secret</code></strong> :&ensp;<code>str</code></dt>
<dd>OAuth2 client secret. Defaults to <code>None</code>.</dd>
<dt><strong><code>code</code></strong> :&ensp;<code>str</code></dt>
<dd>Authorization code. Defaults to <code>None</code>.</dd>
<dt><strong><code>redirect_uri</code></strong> :&ensp;<code>str</code></dt>
<dd>Redirect URI. Defaults to <code>None</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Response from token URL.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetch_tokens(
    self, client_id=None, client_secret=None, code=None, redirect_uri=None, **kwargs
):
    &#34;&#34;&#34;Exchange authorization code for token.

    Args:
        client_id (str): OAuth2 client ID. Defaults to ``None``.
        client_secret (str): OAuth2 client secret. Defaults to ``None``.
        code (str): Authorization code. Defaults to ``None``.
        redirect_uri (str): Redirect URI. Defaults to ``None``.

    Returns:
        dict: Response from token URL.

    &#34;&#34;&#34;
    client_id = client_id or self.client_id
    client_secret = client_secret or self.client_secret
    redirect_uri = redirect_uri or self.redirect_uri
    data = {
        &#34;grant_type&#34;: &#34;authorization_code&#34;,
        &#34;client_id&#34;: client_id,
        &#34;client_secret&#34;: client_secret,
        &#34;code&#34;: code,
        &#34;redirect_uri&#34;: redirect_uri,
    }
    r = self._httpclient.request(
        method=&#34;POST&#34;,
        url=self.token_url,
        json=data,
        endpoint=&#34;/api/oauth2/RequestToken&#34;,
        auth=None,
        **kwargs
    )
    if not r.ok:
        raise CortexError(&#34;%s %s: %s&#34; % (r.status_code, r.reason, r.text))
    try:
        r_json = r.json()
    except ValueError as e:
        raise CortexError(&#34;Invalid JSON: %s&#34; % e)
    else:
        if r.json().get(&#34;error_description&#34;) or r.json().get(&#34;error&#34;):
            raise CortexError(r.text)
        self.access_token = r_json.get(&#34;access_token&#34;)
        self.jwt_exp = self._decode_exp(self.access_token_)
        self.refresh_token = r_json.get(&#34;refresh_token&#34;)
        self.write_credentials()
        return r_json</code></pre>
</details>
</dd>
<dt id="pan_cortex_data_lake.credentials.Credentials.get_authorization_url"><code class="name flex">
<span>def <span class="ident">get_authorization_url</span></span>(<span>self, client_id=None, instance_id=None, redirect_uri=None, region=None, scope=None, state=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate authorization URL.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>client_id</code></strong> :&ensp;<code>str</code></dt>
<dd>OAuth2 client ID. Defaults to <code>None</code>.</dd>
<dt><strong><code>instance_id</code></strong> :&ensp;<code>str</code></dt>
<dd>App Instance ID. Defaults to <code>None</code>.</dd>
<dt><strong><code>redirect_uri</code></strong> :&ensp;<code>str</code></dt>
<dd>Redirect URI. Defaults to <code>None</code>.</dd>
<dt><strong><code>region</code></strong> :&ensp;<code>str</code></dt>
<dd>App Region. Defaults to <code>None</code>.</dd>
<dt><strong><code>scope</code></strong> :&ensp;<code>str</code></dt>
<dd>Permissions. Defaults to <code>None</code>.</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>str</code></dt>
<dd>UUID to detect CSRF. Defaults to <code>None</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str, str</code></dt>
<dd>Auth URL, state</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_authorization_url(
    self,
    client_id=None,
    instance_id=None,
    redirect_uri=None,
    region=None,
    scope=None,
    state=None,
):
    &#34;&#34;&#34;Generate authorization URL.

    Args:
        client_id (str): OAuth2 client ID. Defaults to ``None``.
        instance_id (str): App Instance ID. Defaults to ``None``.
        redirect_uri (str): Redirect URI. Defaults to ``None``.
        region (str): App Region. Defaults to ``None``.
        scope (str): Permissions. Defaults to ``None``.
        state (str): UUID to detect CSRF. Defaults to ``None``.

    Returns:
        str, str: Auth URL, state

    &#34;&#34;&#34;
    client_id = client_id or self.client_id
    instance_id = instance_id or self.instance_id
    redirect_uri = redirect_uri or self.redirect_uri
    region = region or self.region
    scope = scope or self.scope
    state = state or str(uuid.uuid4())
    self.state = state
    return (
        Request(
            &#34;GET&#34;,
            self.auth_base_url,
            params={
                &#34;client_id&#34;: client_id,
                &#34;instance_id&#34;: instance_id,
                &#34;redirect_uri&#34;: redirect_uri,
                &#34;region&#34;: region,
                &#34;response_type&#34;: &#34;code&#34;,
                &#34;scope&#34;: scope,
                &#34;state&#34;: state,
            },
        )
        .prepare()
        .url,
        state,
    )</code></pre>
</details>
</dd>
<dt id="pan_cortex_data_lake.credentials.Credentials.get_credentials"><code class="name flex">
<span>def <span class="ident">get_credentials</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get read-only credentials.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>class</code></dt>
<dd>Read-only credentials.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_credentials(self):
    &#34;&#34;&#34;Get read-only credentials.

    Returns:
        class: Read-only credentials.

    &#34;&#34;&#34;
    return ReadOnlyCredentials(
        self.access_token, self.client_id, self.client_secret, self.refresh_token
    )</code></pre>
</details>
</dd>
<dt id="pan_cortex_data_lake.credentials.Credentials.jwt_is_expired"><code class="name flex">
<span>def <span class="ident">jwt_is_expired</span></span>(<span>self, access_token=None, leeway=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Validate JWT access token expiration.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>access_token</code></strong> :&ensp;<code>str</code></dt>
<dd>Access token to validate. Defaults to <code>None</code>.</dd>
<dt><strong><code>leeway</code></strong> :&ensp;<code>float</code></dt>
<dd>Time in seconds to adjust for local clock skew. Defaults to 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if expired, otherwise <code>False</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jwt_is_expired(self, access_token=None, leeway=0):
    &#34;&#34;&#34;Validate JWT access token expiration.

    Args:
        access_token (str): Access token to validate. Defaults to ``None``.
        leeway (float): Time in seconds to adjust for local clock skew. Defaults to 0.

    Returns:
        bool: ``True`` if expired, otherwise ``False``.

    &#34;&#34;&#34;
    if access_token is not None:
        exp = self._decode_exp(access_token)
    else:
        exp = self.jwt_exp
    now = time()
    if exp &lt; (now - leeway):
        return True
    return False</code></pre>
</details>
</dd>
<dt id="pan_cortex_data_lake.credentials.Credentials.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self, access_token=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Refresh access and refresh tokens.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>access_token</code></strong> :&ensp;<code>str</code></dt>
<dd>Access token to refresh. Defaults to <code>None</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Refreshed access token.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh(self, access_token=None, **kwargs):
    &#34;&#34;&#34;Refresh access and refresh tokens.

    Args:
        access_token (str): Access token to refresh. Defaults to ``None``.

    Returns:
        str: Refreshed access token.

    &#34;&#34;&#34;
    if not self.token_lock.locked():
        with self.token_lock:
            if access_token == self.access_token or access_token is None:
                if self.developer_token is not None and not any(
                    [
                        os.getenv(&#34;PAN_ACCESS_TOKEN&#34;),
                        self._credentials_found_in_instance,
                    ]
                ):
                    parsed_provider = urlparse(self.developer_token_provider)
                    url = &#34;{}://{}&#34;.format(
                        parsed_provider.scheme, parsed_provider.netloc
                    )
                    endpoint = parsed_provider.path
                    r = self._httpclient.request(
                        method=&#34;POST&#34;,
                        url=url,
                        endpoint=endpoint,
                        headers={
                            &#34;Authorization&#34;: &#34;Bearer {}&#34;.format(
                                self.developer_token
                            )
                        },
                        timeout=30,
                        raise_for_status=True,
                    )

                elif all([self.client_id, self.client_secret, self.refresh_token]):
                    data = {
                        &#34;client_id&#34;: self.client_id,
                        &#34;client_secret&#34;: self.client_secret,
                        &#34;refresh_token&#34;: self.refresh_token,
                        &#34;grant_type&#34;: &#34;refresh_token&#34;,
                    }
                    r = self._httpclient.request(
                        method=&#34;POST&#34;,
                        url=self.token_url,
                        json=data,
                        endpoint=&#34;/api/oauth2/RequestToken&#34;,
                        **kwargs
                    )
                else:
                    raise PartialCredentialsError(
                        &#34;Missing one or more required credentials&#34;
                    )

                if r:
                    if not r.ok:
                        raise CortexError(
                            &#34;%s %s: %s&#34; % (r.status_code, r.reason, r.text)
                        )
                    try:
                        r_json = r.json()
                    except ValueError as e:
                        raise CortexError(&#34;Invalid JSON: %s&#34; % e)
                    else:
                        if r.json().get(&#34;error_description&#34;) or r.json().get(
                            &#34;error&#34;
                        ):
                            raise CortexError(r.text)
                        self.access_token = r_json.get(&#34;access_token&#34;, None)
                        self.jwt_exp = self._decode_exp(self.access_token_)
                        if r_json.get(&#34;refresh_token&#34;, None):
                            self.refresh_token = r_json.get(&#34;refresh_token&#34;)
                        self.write_credentials()
                    return self.access_token_</code></pre>
</details>
</dd>
<dt id="pan_cortex_data_lake.credentials.Credentials.remove_profile"><code class="name flex">
<span>def <span class="ident">remove_profile</span></span>(<span>self, profile)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove profile from credentials store.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>profile</code></strong> :&ensp;<code>str</code></dt>
<dd>Credentials profile to remove.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Return value</code> of <code>self.storage.remove_profile()</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_profile(self, profile):
    &#34;&#34;&#34;Remove profile from credentials store.

    Args:
        profile (str): Credentials profile to remove.

    Returns:
        Return value of self.storage.remove_profile()

    &#34;&#34;&#34;
    return self.storage.remove_profile(profile=profile)</code></pre>
</details>
</dd>
<dt id="pan_cortex_data_lake.credentials.Credentials.revoke_access_token"><code class="name flex">
<span>def <span class="ident">revoke_access_token</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Revoke access token.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def revoke_access_token(self, **kwargs):
    &#34;&#34;&#34;Revoke access token.&#34;&#34;&#34;
    c = self.get_credentials()
    data = {
        &#34;client_id&#34;: c.client_id,
        &#34;client_secret&#34;: c.client_secret,
        &#34;token&#34;: c.access_token,
        &#34;token_type_hint&#34;: &#34;access_token&#34;,
    }
    r = self._httpclient.request(
        method=&#34;POST&#34;,
        url=self.token_url,
        json=data,
        endpoint=&#34;/api/oauth2/RevokeToken&#34;,
        **kwargs
    )
    if not r.ok:
        raise CortexError(&#34;%s %s: %s&#34; % (r.status_code, r.reason, r.text))
    try:
        r_json = r.json()
    except ValueError as e:
        raise CortexError(&#34;Invalid JSON: %s&#34; % e)
    else:
        if r.json().get(&#34;error_description&#34;) or r.json().get(&#34;error&#34;):
            raise CortexError(r.text)
        return r_json</code></pre>
</details>
</dd>
<dt id="pan_cortex_data_lake.credentials.Credentials.revoke_refresh_token"><code class="name flex">
<span>def <span class="ident">revoke_refresh_token</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Revoke refresh token.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def revoke_refresh_token(self, **kwargs):
    &#34;&#34;&#34;Revoke refresh token.&#34;&#34;&#34;
    c = self.get_credentials()
    data = {
        &#34;client_id&#34;: c.client_id,
        &#34;client_secret&#34;: c.client_secret,
        &#34;token&#34;: c.refresh_token,
        &#34;token_type_hint&#34;: &#34;refresh_token&#34;,
    }
    r = self._httpclient.request(
        method=&#34;POST&#34;,
        url=self.token_url,
        json=data,
        endpoint=&#34;/api/oauth2/RevokeToken&#34;,
        **kwargs
    )
    if not r.ok:
        raise CortexError(&#34;%s %s: %s&#34; % (r.status_code, r.reason, r.text))
    try:
        r_json = r.json()
    except ValueError as e:
        raise CortexError(&#34;Invalid JSON: %s&#34; % e)
    else:
        if r.json().get(&#34;error_description&#34;) or r.json().get(&#34;error&#34;):
            raise CortexError(r.text)
        return r_json</code></pre>
</details>
</dd>
<dt id="pan_cortex_data_lake.credentials.Credentials.write_credentials"><code class="name flex">
<span>def <span class="ident">write_credentials</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Write credentials.</p>
<p>Write credentials to credentials store.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Return value</code> of <code>self.storage.write_credentials()</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_credentials(self):
    &#34;&#34;&#34;Write credentials.

    Write credentials to credentials store.

    Returns:
        Return value of self.storage.write_credentials()

    &#34;&#34;&#34;
    c = self.get_credentials()
    return self.storage.write_credentials(
        credentials=c, profile=self.profile, cache_token=self.cache_token
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pan_cortex_data_lake.credentials.ReadOnlyCredentials"><code class="flex name class">
<span>class <span class="ident">ReadOnlyCredentials</span></span>
<span>(</span><span>access_token, client_id, client_secret, refresh_token)</span>
</code></dt>
<dd>
<div class="desc"><p>ReadOnlyCredentials(access_token, client_id, client_secret, refresh_token)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pan_cortex_data_lake.credentials.ReadOnlyCredentials.access_token"><code class="name">var <span class="ident">access_token</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="pan_cortex_data_lake.credentials.ReadOnlyCredentials.client_id"><code class="name">var <span class="ident">client_id</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="pan_cortex_data_lake.credentials.ReadOnlyCredentials.client_secret"><code class="name">var <span class="ident">client_secret</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="pan_cortex_data_lake.credentials.ReadOnlyCredentials.refresh_token"><code class="name">var <span class="ident">refresh_token</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 3</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pan_cortex_data_lake" href="index.html">pan_cortex_data_lake</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pan_cortex_data_lake.credentials.Credentials" href="#pan_cortex_data_lake.credentials.Credentials">Credentials</a></code></h4>
<ul class="">
<li><code><a title="pan_cortex_data_lake.credentials.Credentials.access_token" href="#pan_cortex_data_lake.credentials.Credentials.access_token">access_token</a></code></li>
<li><code><a title="pan_cortex_data_lake.credentials.Credentials.cache_token" href="#pan_cortex_data_lake.credentials.Credentials.cache_token">cache_token</a></code></li>
<li><code><a title="pan_cortex_data_lake.credentials.Credentials.client_id" href="#pan_cortex_data_lake.credentials.Credentials.client_id">client_id</a></code></li>
<li><code><a title="pan_cortex_data_lake.credentials.Credentials.client_secret" href="#pan_cortex_data_lake.credentials.Credentials.client_secret">client_secret</a></code></li>
<li><code><a title="pan_cortex_data_lake.credentials.Credentials.decode_jwt_payload" href="#pan_cortex_data_lake.credentials.Credentials.decode_jwt_payload">decode_jwt_payload</a></code></li>
<li><code><a title="pan_cortex_data_lake.credentials.Credentials.developer_token" href="#pan_cortex_data_lake.credentials.Credentials.developer_token">developer_token</a></code></li>
<li><code><a title="pan_cortex_data_lake.credentials.Credentials.developer_token_provider" href="#pan_cortex_data_lake.credentials.Credentials.developer_token_provider">developer_token_provider</a></code></li>
<li><code><a title="pan_cortex_data_lake.credentials.Credentials.fetch_tokens" href="#pan_cortex_data_lake.credentials.Credentials.fetch_tokens">fetch_tokens</a></code></li>
<li><code><a title="pan_cortex_data_lake.credentials.Credentials.get_authorization_url" href="#pan_cortex_data_lake.credentials.Credentials.get_authorization_url">get_authorization_url</a></code></li>
<li><code><a title="pan_cortex_data_lake.credentials.Credentials.get_credentials" href="#pan_cortex_data_lake.credentials.Credentials.get_credentials">get_credentials</a></code></li>
<li><code><a title="pan_cortex_data_lake.credentials.Credentials.jwt_exp" href="#pan_cortex_data_lake.credentials.Credentials.jwt_exp">jwt_exp</a></code></li>
<li><code><a title="pan_cortex_data_lake.credentials.Credentials.jwt_is_expired" href="#pan_cortex_data_lake.credentials.Credentials.jwt_is_expired">jwt_is_expired</a></code></li>
<li><code><a title="pan_cortex_data_lake.credentials.Credentials.refresh" href="#pan_cortex_data_lake.credentials.Credentials.refresh">refresh</a></code></li>
<li><code><a title="pan_cortex_data_lake.credentials.Credentials.refresh_token" href="#pan_cortex_data_lake.credentials.Credentials.refresh_token">refresh_token</a></code></li>
<li><code><a title="pan_cortex_data_lake.credentials.Credentials.remove_profile" href="#pan_cortex_data_lake.credentials.Credentials.remove_profile">remove_profile</a></code></li>
<li><code><a title="pan_cortex_data_lake.credentials.Credentials.revoke_access_token" href="#pan_cortex_data_lake.credentials.Credentials.revoke_access_token">revoke_access_token</a></code></li>
<li><code><a title="pan_cortex_data_lake.credentials.Credentials.revoke_refresh_token" href="#pan_cortex_data_lake.credentials.Credentials.revoke_refresh_token">revoke_refresh_token</a></code></li>
<li><code><a title="pan_cortex_data_lake.credentials.Credentials.write_credentials" href="#pan_cortex_data_lake.credentials.Credentials.write_credentials">write_credentials</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pan_cortex_data_lake.credentials.ReadOnlyCredentials" href="#pan_cortex_data_lake.credentials.ReadOnlyCredentials">ReadOnlyCredentials</a></code></h4>
<ul class="">
<li><code><a title="pan_cortex_data_lake.credentials.ReadOnlyCredentials.access_token" href="#pan_cortex_data_lake.credentials.ReadOnlyCredentials.access_token">access_token</a></code></li>
<li><code><a title="pan_cortex_data_lake.credentials.ReadOnlyCredentials.client_id" href="#pan_cortex_data_lake.credentials.ReadOnlyCredentials.client_id">client_id</a></code></li>
<li><code><a title="pan_cortex_data_lake.credentials.ReadOnlyCredentials.client_secret" href="#pan_cortex_data_lake.credentials.ReadOnlyCredentials.client_secret">client_secret</a></code></li>
<li><code><a title="pan_cortex_data_lake.credentials.ReadOnlyCredentials.refresh_token" href="#pan_cortex_data_lake.credentials.ReadOnlyCredentials.refresh_token">refresh_token</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>